#!/usr/bin/env zsh

typeset -gAH FTAG map map2

FTAG=(
  red    $'\e[38;5;1m'
  green  $'\e[38;5;2m'
  yell   $'\e[38;5;3m'
  blue   $'\e[38;5;4m'
  magen  $'\e[38;5;5m'
  cyan   $'\e[38;5;6m'
  bred   $'\e[01;31m'
  bgreen $'\e[01;32m'
  byell  $'\e[01;33m'
  bblue  $'\e[01;34m'
  bmagen $'\e[01;35m'
  bcyan  $'\e[01;36m'
  res    $'\e[0m'
)

map=(
  "$HOME/.config/zsh"  %ZDOTDIR
  "$HOME/.config"      %XDG_CONFIG_HOME
  "$HOME/.cache"       %XDG_CACHE_HOME
  "$HOME/.local/share" %XDG_DATA_HOME
  "$HOME/Downloads"    %DOWNLOADS
  "$HOME/Documents"    %DOCUMENTS
  "$HOME/bin"          %XDG_BIN_HOME
  "$HOME/vimwiki"      %WIKI_DIR
  "$HOME"              %HOME
)

map2=(
  "$HOME"              %HOME
)

# Not needed
function Ftag::color-file() {
  builtin setopt extendedglob typesetsilent noshortloops rcquotes
  typeset -gH SHORT; SHORT="$1"
  Ftag::map-short "$SHORT"
  SHORT="${SHORT:+${FTAG[green]}${SHORT}${FTAG[res]}}"
}

function Ftag::color-tag() {
  builtin setopt extendedglob typesetsilent noshortloops rcquotes \
    ${${${+REPLY}:#0}:+warncreateglobal}

  local tag=$1
  REPLY="${tag:+${FTAG[bmagen]}${tag}${FTAG[res]}}"
}

function Ftag::map-short() {
  builtin setopt extendedglob typesetsilent noshortloops rcquotes
    # ${${${+SHORT}:#0}:+warncreateglobal}
  typeset -gH SHORT
  # Use 'O' as flag else use another array for $HOME becuase hash is unsorted
  # Color: none
  # SHORT="${${1/(#b)(#s)(${(~j:|:)${(O@k)map}}|)/$map[$match[1]]}}"

  # Color: head
  SHORT=${${1/(#b)(#s)(${(~j:|:)${(O@k)map}}|)/${map[$match[1]]:+${FTAG[green]}${map[$match[1]]}${FTAG[res]}}}}

  # Color: head and tail
  # if [[ ${SHORT:h} != (${~SHORT:t}|\.) ]]; then
  #   reply=( "${SHORT:h}" "${${SHORT:t}:+${FTAG[blue]}${SHORT:t}${FTAG[res]}}")
  # else
  #   reply=( "$SHORT" )
  # fi
  return 0
}

function Ftag::map-back() {
  builtin setopt extendedglob typesetsilent noshortloops rcquotes
  typeset -gH back

  if [[ $1 = /* ]]; then
    back="$1"
    return 0
  elif [[ $1 = %* ]]; then
    back=${${1/(#b)(#s)(${(~j:|:)${(@v)map}}|)/${(k)map[(r)$match[1]]}}}
    return 0
  fi
}

# if [[ $1 = */* ]]; then
#   reply=( ${1%%/*} ${1##*/} )
#   return 0
# fi


function Ftag::show-tags() {
  typeset -a tags files
  typeset -A binds
  tags=( ${(f)"$(tag -Ntf '*')"} )
  files=( ${(f)"$(tag -f '*')"} )

  for ((i=1; i<$#tags; i++)) {
    binds[${(q)files[$i]}]=$tags[$i]
  }

  local f t
  local -a packs
  for f in "${(k)binds[@]}"; do
    tag="${binds[$f]}"
    packs+=( "${(q)f} ${(q)tag//,/, }" )
  done
  # Turns on 'garriglous' mode
  # packs=( "${(on)packs[@]}" )

  integer longest=0
  local -a unpacked formatted
  for t in "${packs[@]}"; do
    unpacked=( "${(Q@)${(z@)t}}" )
    [[ "${#unpacked[1]}" -gt "$longest" ]] && longest="${#unpacked[1]}"
  done

  for t in "${packs[@]}"; do
    unpacked=( "${(Q@)${(z@)t}}" )
    Ftag::color-tag "$unpacked[2]"
    Ftag::map-short "$unpacked[1]"
    # builtin print -n "${(r:longest+1:: :)${(j:/:)reply[@]}} $REPLY"
    builtin print -n "${(r:longest+1:: :)SHORT} $REPLY"
    builtin print
  done
}

Ftag::show-tags

# print -rl ${nfiles:^ntags}

# Could use to split lines
function Ftag::format_length() {
  integer longest=0 longest_left=0 cur_left_len=0 count=1
  local f
  for f in "${(@)${nfiles:^ntags}}"; do
    [[ -z "$f" ]] && continue
    f="${(Q)f}"

    if (( count ++ %2 != 0 )); then
      [[ "${#f}" -gt "$longest_left" ]] && longest_left="${#f}"
      curr_left_len="${#f}"
    else
      curr_left_len+="${#f}"
      curr_left_len+=1
      [[ "$curr_left_len" -gt "$longest" ]] && longest="$curr_left_len"
    fi
  done

  local answer=""
  count=1
  for a in "${(@)${nfiles:^ntags}}"; do
    [[ -z "$f" ]] && continue
    f="${(Q)f}"

    if (( COLUMNS >= longest )); then
      if (( count ++ % 2 != 0 )); then
        answer+="${(r:longest_left+1:: :)f}"
      else
        answer+="$f"$'\n'
      fi
    else
      answer+="$f"$'\n'
    fi
  done
  REPLY="$answer"
  (( COLUMNS >= longest && count % 2 == 0 )) && REPLY="$REPLY"$'\n'
}

# typeset -a ntags nfiles
# for f in "${files[@]}"; do
#   .color-file "$f"
#   nfiles+=( "$REPLY" )
# done
#
# for t in "${tags[@]}"; do
#   .color-tag "$t"
#   ntags+=( "$REPLY" )
# done
# print ${nfiles:^ntags}

# vim: ft=zsh:et:sw=0:ts=2:sts=2:fdm=marker:fmr=[[[,]]]:
