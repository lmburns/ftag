#!/usr/bin/env zsh

############################################################################
#    Author: Lucas Burns                                                   #
#     Email: burnsac@me.com                                                #
#   Created: 2021-06-14 20:45                                              #
#   Description: Fzf TUI for jdberry's tagging on macOS                    #
############################################################################

# == Setup == [[[
emulate -LR zsh
builtin setopt extendedglob typesetsilent warncreateglobal noksharrays
# localoptions noshortloops

0="${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}"
0="${${(M)0:#/*}:-$PWD/$0}"
local prog prog_dir
prog="${0:A:t}"   prog_dir="${0:A:h}"

typeset -gAH FTAG map map2
FTAG=(
  red    $'\e[38;5;1m'  bred   $'\e[01;31m'
  green  $'\e[38;5;2m'  bgreen $'\e[01;32m'
  yell   $'\e[38;5;3m'  byell  $'\e[01;33m'
  blue   $'\e[38;5;4m'  bblue  $'\e[01;34m'
  magen  $'\e[38;5;5m'  bmagen $'\e[01;35m'
  cyan   $'\e[38;5;6m'  bcyan  $'\e[01;36m'
  res    $'\e[0m'
)

map=(
  "$HOME/.config/zsh"  %ZDOTDIR
  "$HOME/.config"      %XDG_CONFIG_HOME
  "$HOME/.cache"       %XDG_CACHE_HOME
  "$HOME/.local/share" %XDG_DATA_HOME
  "$HOME/Downloads"    %DOWNLOADS
  "$HOME/Documents"    %DOCUMENTS
  "$HOME/Pictures"     %PICTURES
  "$HOME/Music"        %MUSIC
  "$HOME/bin"          %XDG_BIN_HOME
  "$HOME/vimwiki"      %WIKI_DIR
  "$HOME"              %HOME
)

map2=(
  "$HOME"              %HOME
)

# TODO: add support for skim
# TODO: does query need to be =query?
# TODO: add support for file paths with spaces
# TODO: use reply/REPLY
# TODO: be consistent with FTAG/FZFTAG for user vars
# Set query as optional args to prevent errors
local -A opts
zparseopts -D -A opts h -help s -skim b -boxes c -lolcat t -toilet -\
    l -local z -zoxide j -jump a -all \
    p:=opts -path:=opts q::=query -query::=query w+=wtag -wutag+=wtag

# zparseopts
zmodload -Fa zsh/zutil b:zparseopts \
  || Ftag::error "zsh/zutil is required to use this program"
# ${commands[@]} array
zmodload -Fa zsh/parameter p:commands \
  || Ftag::error "zsh/parameter is requred to use this program"
# tput $COLUMNS
zmodload zsh/terminfo 2>/dev/null
zmodload zsh/termcap 2>/dev/null
# ]]] == END: Setup

# SECTION: == Functions: Helper == [[[
# FUNCTION: Ftag::error/warning [[[
function Ftag::warning() { builtin print -Pu2 "%F{3}%B[Warning]%f%b: $*"; return 1; }
function Ftag::error() { builtin print -Pu2 "%F{1}%B[Error]%f%b: $*"; exit 1; }
# ]]]

# FUNCTION: Ftag::dep [[[
# $1 - dependency to check
# If '-e', will throw error
function Ftag::dep() {
  local -a opts
  zparseopts -a opts -D ${(s::):-e}
  if (( ${+opts[(r)-e]} )); then
    (( ${+commands[$1]} )) || Ftag::error "%F{2}$1%f is not in PATH"
  else
    (( ${+commands[$1]} ))
  fi
}
# ]]]

# FUNCTION: Ftag::opts [[[
# Check if option was passed
# $@ - string of options; e.g., "h help"
function Ftag::opts() {
  (( ${+opts[-${${(@s. .)@}[1]}]} || ${+opts[--${${(@s. .)@}[2]}]} ))
}
# ]]]

# FUNCTION: Ftag::is_git [[[
function Ftag::is_git() { command git -C "${(z)@}" rev-parse --is-inside-work-tree; }
# ]]]

# FUNCTION: Ftag::declare [[[
# Declare global readonly variable
function Ftag::declare() {
  typeset -p "${@}" &>/dev/null; local exists=$?
  # Returns > 0 if exists
  (( exists != 0 )) && {
    typeset -Hg "${@}"
    return 0
  }
  return 1
}
# ]]]

# FUNCTION: Ftag::color-tag [[[
# $1 - Tag to color
function Ftag::color-tag() {
  builtin setopt extendedglob typesetsilent noshortloops rcquotes \
    ${${${+REPLY}:#0}:+warncreateglobal}

  local tag=$1
  REPLY="${tag:+${FTAG[bmagen]}${tag}${FTAG[res]}}"
}
# ]]]

# FUNCTION: Ftag::map-short [[[
# $1 - File path to color and map to map hash
function Ftag::map-short() {
  builtin setopt extendedglob typesetsilent noshortloops rcquotes
    # ${${${+SHORT}:#0}:+warncreateglobal}
  typeset -gH SHORT
  # Use 'O' as flag else use another array for $HOME becuase hash is unsorted
  # Color: none
  # SHORT="${${1/(#b)(#s)(${(~j:|:)${(O@k)map}}|)/$map[$match[1]]}}"

  # Color: head
  SHORT=${${1/(#b)(#s)(${(~j:|:)${(O@k)map}}|)/${map[$match[1]]:+${FTAG[green]}${map[$match[1]]}${FTAG[res]}}}}

  # Color: head and tail
  # if [[ ${SHORT:h} != (${~SHORT:t}|\.) ]]; then
  #   reply=( "${SHORT:h}" "${${SHORT:t}:+${FTAG[blue]}${SHORT:t}${FTAG[res]}}")
  # else
  #   reply=( "$SHORT" )
  # fi
  return 0
}
# ]]]

# FUNCTION: Ftag::map-back [[[
# $1 - File path to map back to original path
function Ftag::map-back() {
  builtin setopt extendedglob typesetsilent noshortloops rcquotes
  typeset -gH back

  if [[ $1 = /* ]]; then
    back="$1"
    return 0
  elif [[ $1 = %* ]]; then
    back=${${1/(#b)(#s)(${(~j:|:)${(@v)map}}|)/${(k)map[(r)$match[1]]}}}
    return 0
  fi
}

# if [[ $1 = */* ]]; then
#   reply=( ${1%%/*} ${1##*/} )
#   return 0
# fi
# ]]]

# FUNCTION: Ftag::tag [[[
# Tag wrapper to color the output
# TODO: add a header and column separator
function Ftag::tag() {
  typeset -a tags files
  typeset -A binds
  tags=( ${(f)"$(tag -Ntf '*')"} )
  files=( ${(f)"$(tag -f '*')"} )

  for ((i=1; i<$#tags; i++)) {
    binds[${(q)files[$i]}]=$tags[$i]
  }

  local f t
  local -a packs
  for f in "${(k)binds[@]}"; do
    tag="${binds[$f]}"
    packs+=( "${(q)f} ${(q)tag//,/, }" )
  done
  # Turns on 'garriglous' mode
  # packs=( "${(on)packs[@]}" )

  integer longest=0
  local -a unpacked formatted
  for t in "${packs[@]}"; do
    unpacked=( "${(Q@)${(z@)t}}" )
    [[ "${#unpacked[1]}" -gt "$longest" ]] && longest="${#unpacked[1]}"
  done

  for t in "${packs[@]}"; do
    unpacked=( "${(Q@)${(z@)t}}" )
    Ftag::color-tag "$unpacked[2]"
    Ftag::map-short "$unpacked[1]"
    # builtin print -n "${(r:longest+1:: :)${(j:/:)reply[@]}} $REPLY"
    builtin print -n "${(r:longest+1:: :)SHORT} $REPLY"
    builtin print
  done
}
# ]]]

# SECTION: == Unused == [[[
# FUNCTION: Ftag::color-file [[[
# $1 - File path to color
function Ftag::color-file() {
  builtin setopt extendedglob typesetsilent noshortloops rcquotes
  typeset -gH SHORT; SHORT="$1"
  Ftag::map-short "$SHORT"
  SHORT="${SHORT:+${FTAG[green]}${SHORT}${FTAG[res]}}"
}
# ]]]

# FUNCTION: Ftag::format_length [[[
# Could use to split lines based on $#COLUMN
function Ftag::format_length() {
  integer longest=0 longest_left=0 cur_left_len=0 count=1
  local f
  for f in "${(@)${nfiles:^ntags}}"; do
    [[ -z "$f" ]] && continue
    f="${(Q)f}"

    if (( count ++ %2 != 0 )); then
      [[ "${#f}" -gt "$longest_left" ]] && longest_left="${#f}"
      curr_left_len="${#f}"
    else
      curr_left_len+="${#f}"
      curr_left_len+=1
      [[ "$curr_left_len" -gt "$longest" ]] && longest="$curr_left_len"
    fi
  done

  local answer=""
  count=1
  for a in "${(@)${nfiles:^ntags}}"; do
    [[ -z "$f" ]] && continue
    f="${(Q)f}"

    if (( COLUMNS >= longest )); then
      if (( count ++ % 2 != 0 )); then
        answer+="${(r:longest_left+1:: :)f}"
      else
        answer+="$f"$'\n'
      fi
    else
      answer+="$f"$'\n'
    fi
  done
  REPLY="$answer"
  (( COLUMNS >= longest && count % 2 == 0 )) && REPLY="$REPLY"$'\n'
}

# typeset -a ntags nfiles
# for f in "${files[@]}"; do
#   .color-file "$f"
#   nfiles+=( "$REPLY" )
# done
#
# for t in "${tags[@]}"; do
#   .color-tag "$t"
#   ntags+=( "$REPLY" )
# done
# print ${nfiles:^ntags}
# ]]]

# FUNCTION: Ftag::copy [[[
# Determine copy command
# TODO: use this or no?
function Ftag::copy() {
  if Ftag::dep "pbcopyy" ; then FTAG_COPY="pbcopy"
  elif Ftag::dep "xclip" ; then FTAG_COPY="xclip -sel primary"
  elif Ftag::dep "xsel"  ; then FTAG_COPY="xsel -p"
  fi
}
# ]]]

# FUNCTION: OS::notify [[[
# TODO: add option to permanently set notifications
function OS::notify() { osascript -e 'display notification "'"$*"'"'; }
# ]]]

# FUNCTION: Ftag::cleanup [[[
# TODO: look into named pipes
function Ftag::cleanup() {
  rm -f $current_filter
  return 0
}
# ]]]
# ]]] == END: Unused
# ]]] == END: Helper

# SECTION: == Functions: Actions == [[[
# ACTION: Ftag::zoxide [[[
# Switch or query directory with zoxide
function Ftag::zoxide() {
  _ZO_FZF_OPTS="$FZF_DEFAULT_OPTS --prompt ' Zoxide Tag> '" zoxide query -i
}
# ]]]

# ACTION: Ftag::autojump [[[
# Switch or query directory with autojump
function Ftag::autojump() {
  autojump -s | tac | awk 'NR>7{print $2}' | fzf --prompt ' Jump Tag> '
}
# ]]]

# ACTION: Ftag::path::find [[[
# Enter in custom path to switch directories
# TODO: create a prompt to switch paths
function Ftag::path::find() {
  # TAG:
  tag -tf '*' $FZFTAG_PATH | fzf --prompt ' Path> '
  # builtin cd -q "$FZFTAG_PATH" && \
    # tag -el $FZFTAG_PATH | fzf --prompt ' Path> '
}
# ]]]

# ACTION: Ftag::gitui [[[
# If directory is a git-dir (switch git check to func) then use lazygit or tig
function Ftag::gitui() {
  # gitui -d "${(z)@}" - Freezes -- could add grv
  if Ftag::dep "lazygit"; then lazygit -p "${(z)@}"
  elif Ftag::dep "tig"; then tig -C "${(z)@}"
  fi
}
# ]]]

# ACTION: Ftag::wutag [[[
# $1 = directory; $2 = filename; $3 = tag
# Option to use wutag alongside tag with '-w' or wutag alone with '-ww'
function Ftag::wutag() {
  local -a opts
  zparseopts -a opts -D ${(s::):-sar}
  if (( ${+opts[(r)-s]} )); then
    # set
    wutag -d "${1}/" clear "$2"
    wutag -d "${1}/" set "$2" "$3"
  elif (( ${+opts[(r)-a]} )); then
    # add
    wutag -d "${1}/" set "$2" "$3"
  elif (( ${+opts[(r)-r]} )); then
    # remove
    wutag -d "${1}/" clear "$2"
  fi
}
# ]]]

# ACTION: Ftag::RG [[[
# Open directory and interactively search with ripgrep
# Default action is to open in editor
# TODO: add options to fzf
function Ftag::RG() {
  local RG_PREFIX INITIAL_QUERY
  local -a selected opts
  RG_PREFIX="rg --column --hidden --line-number --no-heading --color=always --smart-case "
  INITIAL_QUERY="${*:-}"
  selected=("$(
    FZF_DEFAULT_COMMAND="$RG_PREFIX '$INITIAL_QUERY' || true" \
      fzf --bind "change:reload:$RG_PREFIX {q} || true" \
        --ansi --disabled --query "$INITIAL_QUERY" \
        --delimiter : \
        --bind 'ctrl-e:execute($EDITOR "$(echo {} | cut -d: -f1)" >/dev/tty </dev/tty)' \
        --bind='ctrl-y:execute-silent(echo {+} | cut -d: -f1 | pbcopy)' \
        --preview 'bat --style=numbers,header,changes,snip --color=always --highlight-line {2} {1}' \
        --preview-window 'default:right:60%:~1:+{2}+3/2:border-left'
  )")
  selected=( ${(@s.:.)selected} )
  [[ -n "${selected[1]}" ]] && ${EDITOR} "${selected[1]}" "+${selected[2]}"
}
# ]]]

# ACTION: Ftag::gpg [[[
# Open and edit an encrypted file (-e)
# Default is to encrypted if decrypted or vice versa
function Ftag::gpg() {
  local -a mime opts
  local tmpfile
  zparseopts -a opts -D ${(s::):-e}
  # zmodload -Fa zsh/files b:zf_rm # TODO: use?
  trap "rm -f $tmpfile" EXIT SIGINT SIGTERM
  tmpfile="${TMPDIR:-/tmp}/ftag.dump.$RANDOM"
  mime=(${(@s./.)${(f)$(file --mime-type --brief "${(z)@}")}})
  matched=${(M)mime[@]:#(#i)*pgp-encrypted*}
  # Prevent adding armor if user prefers binary encryption
  # If encrypted and edit
  if [[ -n "${matched}" ]] && (( ${+opts[(r)-e]} )) {
    gpg -dq "${(z)@}" > "$tmpfile"
    "${EDITOR:-vim}" "$tmpfile"
    gpg -eq "$tmpfile"
    [[ -f "${tmpfile}.asc" ]] && mv "${tmpfile}.asc" "${(z)@}"
    [[ -f "${tmpfile}.gpg" ]] && mv "${tmpfile}.gpg" "${(z)@}"
    rm -f "$tmpfile"
  # If encrypted, decrypt it
  } elif [[ -n "${matched}" ]] {
    gpg -dq "${(z)@}" > "$tmpfile"
    mv "$tmpfile" "${(z)@}"
  # If decrypted and edit
  } elif [[ -z "${matched}" ]] && (( ${+opts[(r)-e]} )) {
    "${EDITOR:-vim}" "${(z)@}"
  # If decrypted, encrypt it
  } else {
    gpg -eq "${(z)@}"
    [[ -f "${(z)@}.asc" ]] && mv "${(z)@}.asc" "${(z)@}"
    [[ -f "${(z)@}.gpg" ]] && mv "${(z)@}.gpg" "${(z)@}"
  }
}
# ]]]

# ACTION: Ftag::twf [[[
# Open directory in twf (similar to fzf)
function Ftag::twf() {
  local -a opts
  local prev file
  prev=${${(M)FTAG_PAGER:#bat*}:-cat}
  zparseopts -a opts -D ${(s::):-es}
  if (( ${+opts[(r)-e]} )); then
    file=$(twf -dir "${(z)@}" -previewCmd "${prev} {}")
    [[ -n "$file" ]] && ${EDITOR:-vim} "$file"
  # TODO: use or delete
  elif (( ${+ots[(r)-s]} )); then
    twf -dir "${(z)@}" -previewCmd "${prev} {}"
  fi
}
# ]]]

# ACTION: Ftag::dua [[[
# Open directory in dua interactively
function Ftag::dua() {
  if Ftag::dep "dua"; then
    dua i "$@"
  elif Ftag::dep "ncdu"; then
    ncdu "$@"
  else
    return 1
  fi
}
# ]]]

# ACTION: Ftag::forgit [[[
# Open directory if git and use forgit
# TODO: figure out how to source & add this for everyone
function Ftag::forgit() {
  local -A forgit_cmds
  forgit_cmds[add]="forgit::add"
  forgit_cmds[log]="forgit::log"
  forgit_cmds[diff]="forgit::diff"
  forgit_cmds[ignore]="forgit::ignore"
  forgit_cmds[reset_HEAD_file]="forgit::reset::head"
  forgit_cmds[checkout_file]="forgit::checkout::file"
  forgit_cmds[checkout_branch]="forgit::checkout::branch"
  forgit_cmds[checkout_commit]="forgit::checkout::commit"
  forgit_cmds[clean]="forgit::clean"
  forgit_cmds[stash]="forgit::stash::show"
  forgit_cmds[cherry-pick]="forgit::cherry::pick"
  forgit_cmds[rebase_i]="forgit::rebase"
  forgit_cmds[fixup]="forgit::fixup"
  local reply wfxr
  wfxr=${(@f)$(whence -va forgit::log)}
  [[ -f "$wfxr" ]] && builtin source "$wfxr"

  if [[ -n "$ZINIT" ]]; then
    if [[ -f "${ZINIT[PLUGINS_DIR]}/wfxr---forgit/forgit.plugin.zsh" ]]; then
      builtin source "${ZINIT[PLUGINS_DIR]}/wfxr---forgit/forgit.plugin.zsh"
    elif [[ -f "${ZINIT[HOME_DIR]}/plugins/wfxr---forgit/forgit.plugin.zsh" ]]; then
      builtin source "${ZINIT[HOME_DIR]}/plugins/wfxr---forgit/forgit.plugin.zsh"
    fi
  elif [[ -n "$ZDOTDIR" ]]; then
    # ??
    if [[ -f "${ZDOTDIR}/ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh" ]]; then
      builtin source "${ZDOTDIR}/ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh"
    fi
  fi

  reply=$(print -rl "${(@k)forgit_cmds}" | fzf)
  [[ -n "$reply" ]] && eval "${functions[$forgit_cmds[$reply]]}"
}
# ]]]

# ACTION: Ftag::dotbare [[[
# If dir is git use dotbare in that dir; else use on dotfiles
# Brings up own interactive menu
function Ftag::dotbare() {
  local -a choice action
  local final
  Ftag::dep "dotbare" || return 1
  Ftag::is_git "$@" &>/dev/null || local git="no"
  if [[ $git != "no" ]]; then
    terminal-notifier -title 'first' -message 'x'
    setopt localoptions noautopushd
    builtin cd -q "$@"
    choice=( ${(@f)"$(dotbare)"} )
    action=( ${(@z)choice[1]} )
    final=${action[$(( ${action[(I)dotbare]} + 1 ))]}
    dotbare --git "$final"
  else
    terminal-notifier -title 'second' -message 'x'
    choice=( ${(@f)"$(dotbare)"} )
    action=( ${(@z)choice[1]} )
    final=${action[$(( ${action[(I)dotbare]} + 1 ))]}
    dotbare "$final"
  fi
}
# ]]]

# ACTION: Ftag::glow [[[
# Open directory to browse markdown files
functions Ftag::glow() {
  integer mdfiles
  mdfiles=$(fd . -e md -d1 "${~@}" | wc -l)
  (( mdfiles > 0 )) && glow "${~@}"
}
# ]]]
# ]]] == END: Functions: Actions

# == Functions: Formatting and Display == [[[
# FORMAT: Ftag::default_header [[[
# Default header displayed on commands asking for input
function Ftag::default_header() {
  local -a fig; integer max color; local -A opts
  zparseopts -D -- s:=opts c::=color
  fig=( "${(@f)$(figlet ${(v)opts[(e)-s]} )}" )
  max=${#${(On)fig}[1]}
  print -nPr "%F{${${color/-c/}:-2}}"
  print -lr -- "${(l:(( (COLUMNS+max)/2 )):: :)fig[@]}"
  print -Prn "%f"
  print -Pr -- "%F{1}${(l:COLUMNS::=:):-}%f"
}
# ]]]

# FORMAT: Ftag::boxes/lolcat/toilet [[[
# Format header display from CLI
function Ftag::boxes() {
  (( ${+commands[boxes]} )) && boxes -d tex-box || {
    cat; Ftag::warning "'boxes' is required to use this feature"
  }
}
function Ftag::lolcat() {
  (( ${+commands[lolcat]} )) && lolcat || {
    cat; Ftag::warning "'lolcat' is required to use this feature"
  }
}
function Ftag::toilet() {
  # smblock smmono12
  (( ${+commands[toilet]} )) && toilet -f smmono12 -F border --filter gay "${(j. .)@}" || {
    cat; Ftag::warning "'toilet' is required to use this feature"
  }
}
# ]]]

# FORMAT: Ftag::parse_format [[[
# Display with either toilet, lolcat, or boxes
function Ftag::parse_format() {
  # Toilet:
  if (( FZFTAG_TOILET )); then
    if (( FZFTAG_LOLCAT )); then
      if (( FZFTAG_BOXES )); then
        Ftag::toilet "${(j. .)@}" | Ftag::boxes | Ftag::lolcat
      else
        Ftag::toilet "${(j. .)@}" | Ftag::lolcat          # tc
      fi
    else
      Ftag::toilet "${(j. .)@}"                      # t
    fi
  # Figlet:
  elif (( FZFTAG_LOLCAT )); then
      if (( FZFTAG_BOXES )); then
        $figlet "${(j. .)@}" | Ftag::boxes | Ftag::lolcat # cb
      else
        $figlet "${(j. .)@}" | Ftag::lolcat          # c
      fi
  elif (( FZFTAG_BOXES )); then
      $figlet "${(j. .)@}" | Ftag::boxes             # b
  else
    Ftag::default_header -s "${(j. .)@}" -c 2         # default
  fi
}
# ]]]

# FORMAT: Ftag::usage [[[
# Display typical help message
function Ftag::usage() {
  Ftag::default_header -s "ftag" -c 13
  print -P -- "%F{12}%BUSAGE:%b%f"
  print -P -- "\t%F{14}ftag%f %F{13} [wsh]%f %F{2}<tag>%f"
  print -P -- "\t%F{2}ftag%f is an FZF TUI for jdberry's %F{2}tag%f on macOS"
  print -P -- "\tIt uses 'figlet' by default to display headers, though it is not needed"
  print -P -- "\t%F{2}<tag>%f is optional argument, and if used, it must be exact. There"
  print -P -- "\tare zsh completions to complete tags. For a fuzzy search, use the %F{2}-q%f flag"
  print -P -- "%F{12}%BFLAGS:%b%f"
  print -P -- "\t%F{2}-w%f,%F{2}--wutag%f\t\tAlso tag files with %F{3}wutag%f (%F{2}-ww%f only uses wutag)"
  print -P -- "\t%F{2}-q%f,%F{2}--query <query>%f\tStart fzf with a query"
  print -P -- "\t%F{2}-z%f,%F{2}--zoxide%f\t\tUse %F{3}zoxide%f to select directory to use tags (only shows tagged files)"
  print -P -- "\t%F{2}-j%f,%F{2}--jump%f\t\tUse %F{3}autojump%f to select directory to use tags (only shows tagged files)"
  # print -P -- "\t%F{2}-s%f,%F{2}--skim%f\tUse skim instead of fzf"
  print -P -- "\t%F{2}-h%f,%F{2}--help%f\t\tDisplay this help message"
  print -P -- "%F{12}%BFORMAT:%b%f"
  print -P -- "\t%F{2}-b%f,%F{2}--boxes%f\t\tAdd a box around header with %F{3}boxes%f"
  print -P -- "\t%F{2}-c%f,%F{2}--lolcat%f\t\tColor the header with %F{3}lolcat%f"
  print -P -- "\t%F{2}-t%f,%F{2}--toilet%f\t\tColor and format header with %F{3}toilet%f"
  print -P -- "\t%F{2}-l%f,%F{2}--local%f\t\tUse %F{3}tags%f in local directory"
  print -P -- "\tThe above flags can be used in any combination. Figlet is ran if toilet isn't"
  print -P -- "\tspecified and vice-versa. Although figlet doesn't have a flag, it is ran by default."
  print -P -- "\tThe default printing (no flags specified and figlet installed) looks the nicest."
  print -P -- "%F{12}%BINSIDE FZF:%b%f"
  Ftag::show_keys
}
# ]]]

# FORMAT: Ftag::show_keys [[[
# Display keybindings within fzf
function Ftag::show_keys() {
  print -P -- "\t%F{2}A%f\tAdd/append tags\t%F{14}ACTION_ADD%f"
  print -P -- "\t%F{2}S%f\tSet tags (overwrites)\t%F{14}ACTION_SET%f"
  print -P -- "\t%F{2}D%f\tDelete/remove tags\t%F{14}ACTION_REMOVE%f"
  print -P -- "\t%F{2}R%f\tReload the tag search\t%F{14}ACTION_RELOAD%f"
  print -P -- "\t%F{2}U%f\tShow tag usage\t%F{14}ACTION_USAGE%f"
  print -P -- "\t%F{2}E%f\tEdit selected tags with \$EDITOR\t%F{14}ACTION_EDIT%f"
  print -P -- "\t%F{2}F%f\tOpen directory with file manager in which tagged file resides\t%F{14}ACTION_FILEMANAGER%f"
  print -P -- "\t%F{2}Ctrl-w%f\tOpen directory with %F{3}glow%f if dir contains markdown files\t%F{14}ACTION_GLOW%f"
  print -P -- "\t%F{2}I%f\tOpen %F{3}gitui%f/%F{3}lazygit%f if directory is a git-dir\t%F{14}ACTION_GIT%f"
  print -P -- "\t%F{2}L%f\tSwitch to local mode (i.e., current directory)\t%F{14}ACTION_LOCAL%f"
  print -P -- "\t%F{2}G%f\tSwitch to global mode (i.e., default mode/all tags on file system)\t%F{14}ACTION_GLOBAL%f"
  print -P -- "\t%F{2}Z%f\tSwitch to %F{3}zoxide%f query (i.e., select dir and list tags)\t%F{14}ACTION_ZOXIDE%f"
  print -P -- "\t%F{2}J%f\tSwitch to %F{3}autojump%f query (i.e., select dir and list tags)\t%F{14}ACTION_AUTOJUMP%f"
  print -P -- "\t%F{2}Ctrl-e%f\tEdit a %F{3}gpg%f-encrypted file\t%F{14}ACTION_GPG_EDIT%f"
  print -P -- "\t%F{2}Ctrl-g%f\tEncrypt or decrypt a file with %F{3}gpg%f. If encrypted, decrypt and vice versa\t%F{14}ACTION_GPG%f"
  print -P -- "\t%F{2}Ctrl-d%f\tOpen directory in %F{3}dua%f interactive mode\t%F{14}ACTION_DUA%f"
  print -P -- "\t%F{2}Ctrl-t%f\tOpen directory in %F{3}twf%f to edit file\t%F{14}ACTION_TWF_EDIT%f"
  print -P -- "\t%F{2}Ctrl-r%f\tOpen directory in %F{3}rg%f interactive search\t%F{14}ACTION_RIPGREP%f"
  print -P -- "\t%F{2}Ctrl-f%f\tIf git-dir, open %F{3}forgit%f to select action\t%F{14}ACTION_FORGIT%f"
  print -P -- "\t%F{2}Ctrl-b%f\tIf git-dir, open %F{3}dotbare%f to select action\t%F{14}ACTION_DOTBARE%f"
  print -P -- "\t%F{2}Ctrl-o%f\tOpen directory in finder\t%F{14}ACTION_FINDER%f"
  print -P -- "\t%F{2}O%f\tOpen file in external program based on extension\t%F{14}ACTION_OPEN%f"
  print -P -- "\t%F{2}Alt-d%f\tDelete file, prompted. %F{3}trash-cli%f is used\t%F{14}ACTION_DELETE%f"
  print -P -- "\t%F{2}P%f\tToggle preview of file or directory\t%F{14}ACTION_PREVIEW%f"
  print -P -- "\t%F{2}V%f\tToggle %F{3}bat%f to view file (requires %F{3}bat%f)\t%F{14}ACTION_VIEW%f"
  print -P -- "\t%F{2}Ctrl-y%f\tCopy the file or directory\t%F{14}ACTION_COPY%f"
  print -P -- "\t%F{2}Q%f\tQuit fzf\t%F{14}ACTION_QUIT%f"
  print -P -- "\t%F{2}?%f\tShow keys\t%F{14}ACTION_HELP%f"
  Ftag::env_vars
}
# ]]]

# FORMAT: Ftag::env_vars [[[
# Display environment variables for ftag
function Ftag::env_vars() {
  print -P -- "%F{12}%BENVIRONMENT VARIABLES:%b%f"
  print -P -- "\t%F{5}FTAG_PAGER%f\tPager to view file in or usage (default: %F{2}bat%f, %F{2}less%f)"
  print -P -- "\t%F{5}FTAG_COPY%f\tCopy command to copy path to clipboard (default: %F{2}pbcopy%f)"
  print -P -- "\t%F{5}FTAG_MODIFIER%f\tModifier to bind with fzf (default: %F{3}ctrl%f)"
  print -P -- "\t%F{5}FTAG_FILEMANAGER%f\tFile manager to open when using '%F{3}F%f' in fzf (default: %F{2}lf%f, %F{2}ranger%f, %F{2}xplr%f)"
  print -P -- "\t%F{5}FTAG_FILE_PREV%f\tFzf preview for files (default: %F{2}bat%f)"
  print -P -- "\t%F{5}FTAG_DIR_PREV%f\tFzf preview for directories (default: %F{2}exa%f)"
}
# ]]]
# ]]] == END: Functions: Formatting and Display

# SECTION: == Setting Variables == [[[
typeset -gH FZFTAG_QUERY
FZFTAG_QUERY=${${(v)opts[(I)(-q|--query)]}:-}  # fzf query
export FZFTAG_QUERY

typeset -gH FZFTAG_PATH
FZFTAG_PATH=${${(v)opts[(I)(-p|--path)]}:-}  # search path
export FZFTAG_PATH

typeset -g +h LESS
local space
space="[[:space:]]#"
# Prevent -r from being added twice; -F prevents paging if less than screen size
LESS=${(j. .)${${(@)${(s: :)LESS}}//(${~space}-r${~space}|${~space}-F${~space})/}}
export LESS="-r $LESS"

Ftag::opts "h help" && Ftag::usage && exit 0

local boxes lolcat toilet figlet
Ftag::dep -e "tag"
Ftag::dep "figlet" && figlet="figlet" || figlet="cat"
# ]]] == END: Setting Variables

# SECTION: == Config == [[[
Ftag::declare "FTAG_PAGER=${commands[bat]:-less}"
[[ $FTAG_PAGER == (*/)#bat ]] && FTAG_PAGER="bat --paging=always -f"
Ftag::declare "FTAG_FILEMANAGER=${commands[lf]:-${commands[ranger]}:-${commands[xplr]}}"
Ftag::declare "FTAG_MODIFIER=ctrl"
Ftag::declare "FTAG_ALT=alt"
Ftag::declare "FTAG_COPY=pbcopy"

readonly TTY_REDIRECTION="< /dev/tty > /dev/tty 2>&1"
readonly FTAG_PRINT="+print-query"
readonly FTAG_RELOAD="+reload(env _FZFTAG_INTERNAL=reload $prog)"
readonly FTAG_CHPROMPT="+change-prompt"

readonly ACTION_ADD="execute(env FZFTAG_ACTION=add $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_SET="execute(env FZFTAG_ACTION=set $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_EDIT="execute(env FZFTAG_ACTION=edit $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_REMOVE="execute(env FZFTAG_ACTION=remove $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_USAGE="execute(env FZFTAG_ACTION=usage $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_TEST="execute(env FZFTAG_ACTION=test $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_FILEMANAGER="execute(env FZFTAG_ACTION=file-manager $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_GIT="execute(env FZFTAG_ACTION=git $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_GPG_EDIT="execute(env FZFTAG_ACTION=gpg-edit $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_GPG="execute(env FZFTAG_ACTION=gpg $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_DUA="execute(env FZFTAG_ACTION=dua $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_TWF_EDIT="execute(env FZFTAG_ACTION=twf-edit $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_RIPGREP="execute(env FZFTAG_ACTION=ripgrep $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_FORGIT="execute(env FZFTAG_ACTION=forgit $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_DOTBARE="execute(env FZFTAG_ACTION=dotbare $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_FINDER="execute(env FZFTAG_ACTION=open-finder $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_OPEN="execute(env FZFTAG_ACTION=open $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_DELETE="execute(env FZFTAG_ACTION=delete $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_GLOW="execute(env FZFTAG_ACTION=glow $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"
readonly ACTION_LOCAL="execute(env FZFTAG_STATE_CHANGE=local $prog )${(z)FTAG_RELOAD}${FTAG_CHPROMPT}( Local Tag> )"
readonly ACTION_GLOBAL="execute(env FZFTAG_STATE_CHANGE=global $prog )${(z)FTAG_RELOAD}${FTAG_CHPROMPT}( Global Tag> )"
readonly ACTION_ZOXIDE="execute(env FZFTAG_STATE_CHANGE=zoxide $prog )${(z)FTAG_RELOAD}${FTAG_CHPROMPT}( Zoxide Tag> )"
readonly ACTION_AUTOJUMP="execute(env FZFTAG_STATE_CHANGE=autojump $prog )${(z)FTAG_RELOAD}${FTAG_CHPROMPT}( Jump Tag> )"
readonly ACTION_COPY="execute-silent(echo {1} | ${(z)FTAG_COPY} )"
readonly ACTION_VIEW="execute(bat --style=header,snip -f --paging=always {1} )"
readonly ACTION_RELOAD="reload(env _FZFTAG_INTERNAL=reload $prog)"
readonly ACTION_PREVIEW="toggle-preview"
readonly ACTION_HELP="execute(env _FZFTAG_SHOW=keys $prog | ${(z)FTAG_PAGER} )${(z)FTAG_PRINT}"
readonly ACTION_QUIT="abort"

# TODO: use or remove
readonly ACTION_TWF_SWITCH="execute(env FZFTAG_STATE_CHANGE=twf-switch $prog )${(z)FTAG_RELOAD}${FTAG_CHPROMPT}(TWF Tag>)"

# TODO: create page explaining fzf executes to allow these
typeset -gA FTAG_KEYBINDINGS
: ${FTAG_KEYBINDINGS[A]:=$ACTION_ADD}
: ${FTAG_KEYBINDINGS[S]:=$ACTION_SET}
: ${FTAG_KEYBINDINGS[E]:=$ACTION_EDIT}
: ${FTAG_KEYBINDINGS[D]:=$ACTION_REMOVE}
: ${FTAG_KEYBINDINGS[U]:=$ACTION_USAGE}
: ${FTAG_KEYBINDINGS[T]:=$ACTION_TEST}
: ${FTAG_KEYBINDINGS[F]:=$ACTION_FILEMANAGER}
: ${FTAG_KEYBINDINGS[I]:=$ACTION_GIT}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-b]:=$ACTION_DOTBARE}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-e]:=$ACTION_GPG_EDIT}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-g]:=$ACTION_GPG}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-d]:=$ACTION_DUA}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-t]:=$ACTION_TWF_EDIT}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-r]:=$ACTION_RIPGREP}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-o]:=$ACTION_FINDER}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-w]:=$ACTION_GLOW}
: ${FTAG_KEYBINDINGS[O]:=$ACTION_OPEN}
: ${FTAG_KEYBINDINGS[${FTAG_ALT}-d]:=$ACTION_DELETE}
: ${FTAG_KEYBINDINGS[L]:=$ACTION_LOCAL}
: ${FTAG_KEYBINDINGS[G]:=$ACTION_GLOBAL}
: ${FTAG_KEYBINDINGS[Z]:=$ACTION_ZOXIDE}
: ${FTAG_KEYBINDINGS[J]:=$ACTION_AUTOJUMP}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-y]:=${(z)ACTION_COPY}}
: ${FTAG_KEYBINDINGS[V]:=$ACTION_VIEW}
: ${FTAG_KEYBINDINGS[R]:=$ACTION_RELOAD}
: ${FTAG_KEYBINDINGS[P]:=$ACTION_PREVIEW}
: ${FTAG_KEYBINDINGS[Q]:=$ACTION_QUIT}
: ${FTAG_KEYBINDINGS[esc]:=$ACTION_QUIT}    # ??
: ${FTAG_KEYBINDINGS[?]:=$ACTION_HELP}

: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-f]:=$ACTION_FORGIT}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-s]:=$ACTION_TWF_SWITCH}

typeset -a FTAG_ACTIONS
FTAG_ACTIONS=( ${(@)${(k)FTAG_KEYBINDINGS//(#m)*/\-\-bind=$MATCH:${FTAG_KEYBINDINGS[$MATCH]}}} )
# ]]] == END: Config

# SECTION: == Create Filter == [[[
# File path content marks how to execute next command in the main loop
local current_filter
current_filter=${XDG_RUNTIME_DIR:-${XDG_CACHE_DIR:-${TMP-/tmp}}}/tag-filter
if ! touch $current_filter; then
  echo "${prog}: Can't create a marker file needed for internal state management." >&2
fi
# ]]] == END: Create Filter

# SECTION: == Actions == [[[
# Keys to show within the TUI
if [[ "${_FZFTAG_SHOW}" = "keys" ]]; then
  Ftag::default_header -s "ftag keybindings" -c 5
  local header
  local -a keys
  # Not sure how to put this in array as one element other than this, it reads as 3
  header=$(print -P "%F{9}KEY%f\t%F{13}ACTION%f\t%F{11}FZFTAG_ACTION%f")
  line=$(print -P "%F{9}===%f\t%F{13}======%f\t%F{11}=============%f")
  keys=( $header $line )
  keys+=( ${(@)${(f)"$(Ftag::show_keys)"}/$'\t'/} )
  print -rl -- $keys | column -ts $'\t'
  # print -rl -- ${(@)${(f)"$(Ftag::show_keys)"}/$'\t'/} | column -ts $'\t'
  exit 0
fi

# FIXME: try and use this instead of awk
# declare -a input; input=($@)
# print -l "${input[@]/(#b)([^\/]##\/)##([^\/]##)*/${match[3]}}"

if [[ -n "$FZFTAG_ACTION" ]]; then
  clear
  # Get the filename
  pathf="$(awk '{print $1}' $@)"
  [[ -f $pathf ]] || echo 'Not a file'
  case "$FZFTAG_ACTION" in
    (test)
      # Testing for development
      Ftag::parse_format "test"
      vared -cp "Set tags for ${pathf:t3}: " tag
      ;;
    (set)
      local fname fdir tag file
      Ftag::parse_format "set tags"
      vared -cp "Set tags for ${pathf:t3}: " tag
      for file in "${(f)pathf[@]}"; do
        # Wutag only works if variables are set first
        fname="${file:t}" fdir="${file:h}"
        # Wutag is called in addition unless -ww
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -s "$fdir" "$fname" "$tag"
        } elif (( FZFTAG_WTAG == 1 )) {
          tag --set "${tag}" "$file"
          Ftag::wutag -s "$fdir" "$fname" "$tag"
        } else {
          tag --set "${tag}" "$file"
        }
      done
      ;;
    (add)
      local fname fdir tag file
      Ftag::parse_format "add tags"
      vared -cp "Add tags for ${pathf:t3}: " tag
      for file in "${(f)pathf[@]}"; do
        fname="${file:t}" fdir="${file:h}"
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -a "$fdir" "$fname" "$tag"
        } elif (( FZFTAG_WTAG == 1 )) {
          tag --add "${tag}" "$file"
          Ftag::wutag -a "$fdir" "$fname" "$tag"
        } else {
          tag --add "${tag}" "$file"
        }
      done
      ;;
    (remove)
      local fname fdir tag file
      Ftag::parse_format "remove tags"
      vared -cp "Remove tags for ${pathf:t3}: " tag
      for file in "${(f)pathf[@]}"; do
        fname="${file:t}" fdir="${file:h}"
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -r "$fdir" "$fname"
        } elif (( FZFTAG_WTAG == 1 )) {
          tag --remove "${tag}" "$file"
          Ftag::wutag -r "$fdir" "$fname"
        } else {
          tag --remove "${tag}" "$file"
        }
      done
      ;;
    (ripgrep)
      local fname fdir yesno keyw
      Ftag::parse_format "ripgrep search"
      vared -cp "Local [Y/n]: " yesno
      vared -cp "Ripgrep keyword: " keyw
      [[ "$yesno" == (#i)n ]] && {
        () {
            setopt localoptions noautopushd
            builtin cd -q "${pathf:h}"
            Ftag::RG "$keyw"
          };
        } || Ftag::RG "$keyw"
      ;;
    (usage)
      tag --usage | ${(z)FTAG_PAGER}
      ;;
    (edit)
      # TODO: maybe change to open
      ${EDITOR:-vim} "$pathf"
      ;;
    (file-manager)
      $FTAG_FILEMANAGER "${pathf:h}"
      ;;
    (git)
      Ftag::is_git "${pathf:h}" >/dev/null || return 1
      Ftag::gitui "${pathf:h}"
      ;;
    (forgit)
      Ftag::is_git "${pathf:h}" >/dev/null || return 1
      Ftag::forgit
      ;;
    (dotbare)
      Ftag::dotbare "${pathf:h}"
      ;;
    (gpg-edit)
      Ftag::gpg -e "$pathf"
      ;;
    (gpg)
      Ftag::gpg "$pathf"
      ;;
    (dua)
      Ftag::dua "${pathf:h}"
      ;;
    (twf-edit)
      Ftag::dep "twf" && Ftag::twf -e "${pathf:A:h}"
      ;;
    (glow)
      Ftag::glow "${pathf:A:h}"
      # glow "${tag_arg:A:h}"
      ;;
    (open-finder)
      open "${pathf:A:h}" && exit 0
      ;;
    (open)
      # OS::notify "${pathf:e}"
        case "$(file --mime-type -b ${pathf:A})" in
          (text/html) w3m "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (text/*|*/xml|application/pgp-encrypted) ${(z)FTAG_PAGER} "${pathf:A}" ;;
          (application/zip) atool --list -- "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (image/*) Ftag::dep "feh" && ${commands[setsid]:-nohup} feh -. -x -B black -g 900x600-15+60 "${pathf:A}" || \
                      Ftag::dep "sxiv" && ${commands[setsid]:-nohup} sxiv -ai "${pathf:A}" ;;
          (video/*) ${commands[setsid]:-nohup} mpv --ontop --no-border --force-window --autofit=500x280 --geometry=-15-53 "${pathf:A}" ;;
          (audio/*) mpv "${pathf:A}" ;;
          (application/pdf|application/vnd*|application/epub*) ${commands[setsid]:-nohup} zathura "${pathf:A}" ;;
          (image/x-xcf) ${commands[setsid]:-nohup} gimp "${pathf:A}" ;;
      esac
      # (image/*) viu "${pathf:A}" ;;
      # text/troff) man ./ "${pathf:A}" | col -b | ${(z)FTAG_PAGER} ;;
      # */pdf) pdftotext -l 10 -nopgbrk -q "${pathf:A}" - | ${(z)FTAG_PAGER} ;;
      # image/*) chafa --fill=block --symbols=block -c 256 -s 80x"${HEIGHT}" "${pathf:A}" || exit 1;;
      # video/* | audio/*|application/octet-stream) mediainfo "${pathf:A}" || exit 1;;
      # application/vnd.openxmlformats-officedocument.wordprocessingml.document) docx2txt "${pathf:A}" || exit 1;;
      # TODO: Change this to preview
      case "${pathf:e}" in
          (tgz|tar.gz) tar tzf "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (tar.bz2|tbz2) tar tjf "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (tar.txz|txz) xz --list "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (tar) tar tf "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (jar|war|ear|oxt) unzip -l "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (rar) unrar l "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (7z) 7z l "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          ([1-8]) man "${pathf:A}" | col -b | ${(z)FTAG_PAGER} ;;
          (o) nm "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (torrent) transmission-show "${pathf:A}" | "${(z)FTAG_PAGER}" ;;
          (iso) iso-info --no-header -l "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (odt|ods|odp|sxw) odt2txt "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (doc) catdoc "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (docx) docx2txt "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          # (csv) bat "${pathf:A}" | sed s/,/\\n/g ;;
          # (csv) bat --paging=always -f -l csv "${pathf:A}" ;;
          (csv) ${(z)${${(M)FTAG_PAGER:#bat*}:+${FTAG_PAGER} -l csv}} "${pathf:A}" ;;
          (json) jq --color-output . "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (asc) cat "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (sha1|sha256|sha512|md5) rhash -c "${pathf:A}" | ${(z)FTAG_PAGER} ;;
          (ipynb) jupview -t KimbieDark "${pathf:A}" | ${(z)FTAG_PAGER} ;;
      esac
      ;;
    (delete)
      local yesno
      vared -cp "Delete file ${pathf:t3}? [Y/n] " yesno
      [[ "$yesno" == (#i)y ]] && {
        Ftag::dep "trash-put" && {
          trash-put "${pathf:A}" && OS::notify "${pathf:A} deleted"
        }
      }
      ;;
  esac
  clear
  print -Pr -- "%F{1}${(l:COLUMNS::=:):-}%f"
  print "End of 'ftag "$FZFTAG_ACTION"' output. Press any key to continue"
  print -Pr -- "%F{1}${(l:COLUMNS::=:):-}%f"
  read
  exit $?
fi
# ]]] == END: Actions

# SECTION: == State Change == [[[
local FZFTAG_CMD dir_switch
if [[ -n "$FZFTAG_STATE_CHANGE" ]]; then
  case "$FZFTAG_STATE_CHANGE" in
    local)
      FZFTAG_CMD="-l"
      ;;
    global)
      FZFTAG_CMD="-tf *"
      ;;
    path)
      dir_switch=$(Ftag::path::find)
      FZFTAG_CMD="-tf * ${(q)dir_switch}"
      ;;
    zoxide)
      dir_switch=$(Ftag::zoxide)
      FZFTAG_CMD="-tf * ${(q)dir_switch}"
      ;;
    autojump)
      dir_switch=$(Ftag::autojump)
      FZFTAG_CMD="-tf * ${(q)dir_switch}"
      ;;
  esac

  echo "$FZFTAG_CMD" > $current_filter
  exit
fi
# ]]] == END: State Change

# SECTION: == Reload == [[[
local filter
if [[ -n "$_FZFTAG_RELOAD" ]]; then
  filter="$(<$current_filter)"
  # TAG:
  output="$(tag ${(z)filter} | column -ts $'\t')"

  if [[ -n "$output" ]]; then
    echo "$output"
  else
    echo "No tags were found: $filter"
  fi
  exit
fi
# ]]] == END: Reload

# SECTION: == Remove Filter == [[[
# No state change, no action, and no reload, remove filter
# if [[ -z "${FZFTAG_STATE_CHANGE+1}" ]] && [[ -z "${FZFTAG_ACTION+1}" ]] && [[ "${_FZFTAG_INTERNAL}" != "reload" ]]; then
if [[ -z "${FZFTAG_STATE_CHANGE+1}" &&
  -z "${FZFTAG_ACTION+1}" && "${_FZFTAG_INTERNAL}" != "reload" ]]; then
  rm -f "$current_filter"
fi
# ]]] == END: Remove Filter

# SECTION: == Main Loop == [[[
# Variables have to be exported to be picked up on the next iteration of the loop
typeset -giH FZFTAG_WTAG FZFTAG_BOXES FZFTAG_LOLCAT FZFTAG_TOILET
typeset -gH  FZFTAG_STATE_CHANGE
while (( $? != 130 )); do

  if Ftag::opts "w wutag"; then
    if Ftag::dep "wutag"; then
      if (( $#wtag > 1 )) {
        export FZFTAG_WTAG=2
      } else {
        export FZFTAG_WTAG=1
      }
    else
      Ftag::warning "%F{2}wutag%f is not in PATH
      Install %F{2}wutag%f or don't use %F{2}-w%f,%F{2}--wutag%f'"
    fi
  fi

  Ftag::opts "b boxes"  && export FZFTAG_BOXES=1
  Ftag::opts "c lolcat" && export FZFTAG_LOLCAT=1
  Ftag::opts "t toilet" && export FZFTAG_TOILET=1

  local tag_arguments
  # If writeable, that means theres a state change
  if [[ -w "$current_filter" ]]; then
    tag_arguments="$(<$current_filter)"
  else
  # First time ran
    if Ftag::opts "l local"; then
      tag_arguments="-l"
    elif Ftag::opts "p path"; then
      tag_arguments="-tf * $FZFTAG_PATH"
    elif Ftag::opts "z zoxide"; then
      Ftag::dep -e "zoxide"
      dir_switch=$(Ftag::zoxide)
      tag_arguments="-tf * $dir_switch"
    elif Ftag::opts "j jump"; then
      Ftag::dep -e "autojump"
      dir_switch=$(Ftag::autojump)
      tag_arguments="-tf * $dir_switch"
    else
      # Don't quote *
      tag_arguments="-tf ${@:-*}"
    fi
    echo "$tag_arguments" >! $current_filter
  fi

  # TODO: pickup with-nth on reload
  # Set initial prompt
  local -a FZFTAG_OPTS
  if Ftag::opts "l local" || [[ "$FZFTAG_STATE_CHANGE" == "local" ]]; then
    FZFTAG_OPTS=( "--prompt ' Local Tag> '" )
  elif Ftag::opts "p path" || [[ "$FZFTAG_STATE_CHANGE" == "path" ]]; then
    FZFTAG_OPTS=( "--prompt ' Path> '" )
  elif Ftag::opts "z zoxide" || [[ "$FZFTAG_STATE_CHANGE" == "zoxide" ]]; then
    FZFTAG_OPTS=( "--prompt ' Zoxide Tag> '" )
  elif Ftag::opts "j jump" || [[ "$FZFTAG_STATE_CHANGE" == "autojump" ]]; then
    FZFTAG_OPTS=( "--prompt ' Jump Tag> '" )
  else
    # FZFTAG_OPTS=( "--prompt 'Tag> '" "--delimiter /" "--with-nth 4.." )
    FZFTAG_OPTS=( "--prompt 'Tag> '" )
  fi

  if [[ "${_FZFTAG_INTERNAL}" == "reload" ]]; then
    # TAG:
    tag "${(z)tag_arguments}" | column -t
    exit $?
  fi

  local FILE_PREV DIR_PREV
  local ftag_file_prev ftag_dir_prev
  ftag_file_prev=${FTAG_FILE_PREV:-bat --style=numbers --color=always}
  ftag_dir_prev=${FTAG_DIR_PREV:-exa -TL 3}
  FILE_PREV="([[ -f {1} ]] && $ftag_file_prev {1})"
  DIR_PREV="([[ -d {1} ]] && $ftag_dir_prev {1} | less)"
  # TAG:
  tag "${(z)tag_arguments}" \
    | column -t \
    | fzf \
    ${${(z)${(j. .)FZFTAG_OPTS}}//\'} \
    --ansi \
    --query "$FZFTAG_QUERY" \
    --multi \
    --info=inline \
    --pointer '➤' \
    --no-height \
    --preview-window=':hidden,right:60%' \
    --preview "$FILE_PREV || $DIR_PREV" \
    "${FTAG_ACTIONS[@]}"
done

# ]]] == END: Main Loop

# vim: ft=zsh:et:sw=0:ts=2:sts=2:fdm=marker:fmr=[[[,]]]:
