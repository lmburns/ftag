#!/usr/bin/env zsh

############################################################################
#    Author: Lucas Burns                                                   #
#     Email: burnsac@me.com                                                #
#   Created: 2021-06-14 20:45                                              #
#   Description: Fzf TUI for jdberry's tagging on macOS                    #
############################################################################

# == Setup == [[[
emulate -LR zsh
builtin setopt extendedglob typesetsilent noksharrays

0="${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}"
0="${${(M)0:#/*}:-$PWD/$0}"
local prog prog_dir
prog="${0:A:t}"   prog_dir="${0:A:h}"

# TODO: does query need to be =query?
# TODO: confirm support for file paths with spaces
# TODO: be consistent with FTAG/FZFTAG for user vars
# TODO: find a way to display hidden tagged files
# ]]] == END: Setup

# SECTION: == Functions: Helper == [[[
# FUNCTION: +Ftag::msg [[[
# Map colors to FTAG array and recognize errors and warnings
function +Ftag::msg() {
  builtin emulate -LR zsh
  setopt extendedglob noksharrays noshortloops warncreateglobal
  local opt msg
  typeset -gi ret
  local -a match mbegin mend
  [[ $1 = -* ]] && { opt=$1; shift; }
  msg=${${(j: :)${@}}//\%/%%}
  msg=${msg/(#b)\{(warn|err)\}/\{bred\}${${${(M)match:#warn}:+\[Warning\]}:-\[Error\]}:\{res\} }
  msg=${${msg//(#b)([\{]([^\}]##)[\}])/${FTAG[${${match[1]}//([\{\}])/}]}}}
  if [[ -n $opt && $opt = -p ]] {
    [[ -n ${(M)msg:#(#i)*(warn*|err*)*} ]] && {
      print -ru2 -- $msg && ret=1
    } || print -r -- $msg && ret=0
  return ret
  } else {
    REPLY=${msg}${FTAG[res]}
  }
}
# ]]]

# FUNCTION: Ftag::dep [[[
# $1 - dependency to check
# If '-e', will throw error
function Ftag::dep() {
  [[ $1 = -e ]] && { integer err=1; shift; }
  if (( err )); then
    { (( ${+commands[$1]} )); return 0 } || { Ftag::msg -p "{err}{green}${1}{res} is not in {yell}\$PATH{res}"; return 1; }
  else
    (( ${+commands[$1]} )); return 0
  fi
}
# ]]]

# FUNCTION: Ftag::opts [[[
# Check if option was passed
# $@ - string of options; e.g., "h help"
function Ftag::opts() {
  ( (( ${+opts[-${${(@s. .)@}[1]}]} || ${+opts[--${${(@s. .)@}[2]}]} )) ) && return 0
}
# ]]]

# FUNCTION: Ftag::is_git [[[
function Ftag::is_git() { command git -C "${(z)@}" rev-parse --is-inside-work-tree; }
# ]]]

# FUNCTION: Ftag::declare [[[
# Declare global variable for config
function Ftag::declare() {
  [[ $1 = -* ]] && { local opt=$1; shift; }
  local -i set; set=$+parameters[${${(s:=:)@}[1]}]
  (( set )) || {
    [[ $opt = (#i)-a ]] && {
      eval "typeset -Hg${opt#-} ${${(s:=:)@}[1]}=${(fz)${(s:=:)@}[2]}"
    } || typeset -gH "${${(s:=:)@}[1]}=${${(s:=:)@}[2,-1]}"
    return 0
  }
  return 1
}
# ]]]

# FUNCTION: Ftag::color-tag [[[
# $1 - Tag to color
function Ftag::color-tag() {
  builtin emulate -LR zsh
  setopt extendedglob typesetsilent rcquotes ${${${+REPLY}:#0}:+warncreateglobal}
  REPLY="${1:+${FTAG[bmagen]}${${1//(#m)(\|)/${FTAG[blue]}${MATCH}${FTAG[res]}${FTAG[bmagen]}}}${FTAG[res]}}"
  return 0
}
# ]]]

# FUNCTION: Ftag::map-short [[[
# $1 - File path to color and map to map hash
function Ftag::map-short() {
  builtin emulate -LR zsh
  setopt extendedglob typesetsilent noshortloops rcquotes
  typeset -gH SHORT
  local -a match mbegin mend
  # Use 'O' as flag else use another array for $HOME becuase hash is unsorted
  # Color: head
  SHORT=${${1/(#b)(#s)(${(~j:|:)${(O@k)FTAG_DIR_MAP}}|)/${FTAG_DIR_MAP[$match[1]]:+${FTAG[green]}${FTAG_DIR_MAP[$match[1]]}${FTAG[res]}}}}

  # Color: head and tail
  # if [[ ${SHORT:h} != (${~SHORT:t}|\.) ]]; then
  #   reply=( "${SHORT:h}" "${${SHORT:t}:+${FTAG[blue]}${SHORT:t}${FTAG[res]}}")
  # else
  #   reply=( "$SHORT" )
  # fi
  return 0
}
# ]]]

# FUNCTION: Ftag::map-back [[[
# $1 - File path to map back to original path
function Ftag::map-back() {
  builtin emulate -LR zsh
  setopt extendedglob typesetsilent rcquotes ${${${+reply}:#0}:+warncreateglobal}
  # typeset -ga reply; reply=()
  local -a match mend mbegin opts
  local f

  for f in "${@}"; do
    if [[ "$f" = (#s)%* ]] {
      reply=( ${${f/(#b)(#s)(${(~j:|:)${(@v)FTAG_DIR_MAP}}|)/${(~k)FTAG_DIR_MAP[(r)$match[1]]}}} )
    } else {
      reply=( "$f" )
    }
  done
}
# ]]]

# FUNCTION: Ftag::tag [[[
# Tag wrapper to color the output
# TODO: add a header and column separator
# TODO: speed up
function Ftag::tag() {
  emulate -LR zsh
  setopt extendedglob warncreateglobal typesetsilent noksharrays \
            noshortloops nomonitor nonotify

  local -a targs tags fargs files tmp
  fargs=( "${(Q@)${(@z)@}}" )

  # Have a single check for wrapper instead of case statement for speed
  (( WRAPPER )) && {
    local action=${fargs[1]#-}
    case "$fargs" in
      (-s*|--set*)
        [[ $#fargs -eq 3 && $fargs[1] = -(s|-set) && $fargs = -(s*|-set*)
        ]] && {
          command tag --set "$fargs[2]" "$fargs[3]" 2>/dev/null && {
            +Ftag::msg -p "{brblue}Tag:{res} $fargs[2]"$'\t'"{brblue}Set:{res} $fargs[3]"
          } || +Ftag::msg -p '{err}tag cannot be set'
        }
        ;;
      (-r*|--remove*)
        [[ $#fargs -eq 3 && $fargs[1] = -(r|-remove) && $fargs = -(r*|-remove*)
        ]] && {
          command tag --remove "$fargs[2]" "$fargs[3]" 2>/dev/null && {
            +Ftag::msg -p "{brblue}Tag:{res} $fargs[2]"$'\t'"{brblue}Removed:{res} $fargs[3]"
          } || +Ftag::msg -p '{err}tag cannot be removed'
        }
        ;;
      (-a*|--add*)
        [[ $#fargs -eq 3 && $fargs[1] = -(a|-add) && $fargs = -(a*|-add*)
        ]] && {
          command tag --add "$fargs[2]" "$fargs[3]" 2>/dev/null && {
            +Ftag::msg -p "{brblue}Tag:{res} $fargs[2]"$'\t'"{brblue}Added:{res} $fargs[3]"
          } || +Ftag::msg -p '{err}tag cannot be added'
        }
        ;;
      (-l|--list)
        [[ $#fargs -eq 1 && $fargs[1] = -(l|-list) ]] && {
          tmp=( ${${${(@)${(@f)"$(tag -Al)"}/(#m)([[:space:]]|(#e))/---${MATCH}}//[[:space:]]/}//(#m)---(#e)/--- } )
          tags=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[2]}}} )
          files=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[1]}}} )
        }
        ;;
      (-u*|--usage*)
        () {
          emulate -LR zsh
          setopt extendedglob warncreateglobal noksharrays noshortloops nokshglob
          local -a tcnts ttags
          if [[ $#fargs -eq 1 && $fargs[1] = -(u|-usage) ]] {
            tcnts=( ${${(@f)"$(tag --usage)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[1]}} )
            ttags=( ${${(@f)"$(tag --usage)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}} )
          } elif [[ $#fargs -eq 2 && $fargs[1] = -(u|-usage) && $~fargs[2] = (#s)(\~|\/|.##)*/#* ]] {
            tcnts=( ${${(@f)"$(tag --usage ${(z)~fargs[2]})"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[1]}} )
            ttags=( ${${(@f)"$(tag --usage ${(z)~fargs[2]})"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}} )
          } elif [[ $#fargs -eq 3 && $fargs[1] = -(u|-usage) && $~fargs[3] = (#s)(\~|\/|.##)*/#* ]] {
            [[ $fargs[2] = [[:ascii:]]## ]] && {
              tcnts=( ${${(@f)"$(tag --usage ${(z)~fargs[3]})"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[1]}} )
              ttags=( ${${(@f)"$(tag --usage ${(z)~fargs[3]})"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}} )
              local exists=${(M)ttags:#${fargs[2]}}
              [[ -n $exists ]] && {
                # Normal tag does not do this; selecting one tag in a directory
                tcnts=${(@)${tcnts[${ttags[(rI)$exists]}]}}
                Ftag::color-tag "$exists"
                +Ftag::msg -p "{brgreen}$tcnts{res} $REPLY"
                return 0
              } || { +Ftag::msg -p "{err}{cyan}$fargs[2]{res} is not an existing tag"; return 1; }
            }
          }
          # SEE: if can fallthrough
          local -a packs unpacked;    integer i longest=0 adjust;     local t
          for (( i=1; i<=$#ttags; i++ )) { packs+=( "${(q)${tcnts[$i]}} ${(q)${ttags[$i]}}" ); }
          for t ($packs) { unpacked=( "${(Q@)${(z@)t}}" ); (( $#unpacked[1] > $longest )) && longest=$#unpacked[1]; }
          adjust=$(( ${#FTAG[brgreen]} + ${#FTAG[res]} ))
          for t ($packs) {
            unpacked=( "${(Q@)${(z@)t}}" )
            Ftag::color-tag "$unpacked[2]"
            unpacked[1]=${FTAG[brgreen]}${unpacked[1]}${FTAG[res]}
            builtin print -n "${(r:longest+adjust+1:: :)unpacked[1]} $REPLY"
            builtin print
          }
        }
        ;;
      (-h|--help)
        # tag -h
        +Ftag::msg -p "{bgreen}External tag help:{res}" \
          $'\n'"${${${(@)$(command tag --help)}//(#m)(${(~j:|:)__FTAG_EXTERNAL_OPTS})/${FTAG[yell]}${MATCH}${FTAG[res]}}//(#m)(-##[[:alnum:]]##)/${FTAG[green]}${MATCH}${FTAG[res]}}"
        ;;
      (*-[[:alpha:]]#g[[:alpha:]]#*|*--garrulous*)
        () {
          emulate -LR zsh
          setopt extendedglob warncreateglobal noksharrays noshortloops nokshglob
          integer -g GARRULOUS=1
          local -a fst_fargs=( ${(s::)${fargs[1]#-}} )
          if [[ $#fargs -eq 1 && ( $#fst_fargs -eq 1 && $fst_fargs[1] = (g|l) ||
              ( $#fst_fargs -eq 2 && $fst_fargs[1] = (g|l) && $fst_fargs[2] = (g|l) ) )
          ]] {
            # Only passing -g implies -l
            tmp=( ${${${(@)${(@f)"$(tag -Al)"}/(#m)([[:space:]]|(#e))/---${MATCH}}//[[:space:]]/}//(#m)---(#e)/--- } )
            tags=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[2]}}} )
            files=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[1]}}} )
          } elif [[ $#fargs -eq 2 && ( ( $#fst_fargs -eq 2 && $fargs = *f* ) ||
                    $#fst_fargs -eq 3 && $fargs = *f* && $#fargs = *t* ) && $fargs[-1] = (\*|[[:alnum:]]##)
          ]] {
            # Same behavior for tag -gf '*' and tag -gtf '*'
            fargs[1]=${fargs[1]/t/}
            targs=( "-Ntf" "${fargs[-1]}" )
          } elif [[ $#fargs -eq 3 && ( ( $#fst_fargs -eq 2 && $fargs = *f* ) ||
                    $#fst_fargs -eq 3 && $fargs = *f* && $fargs = *t* ) && $fargs[-1] = (#s)(\~|\/|.##)*/#*
          ]] {
            # Same behavior for tag -gf '<tag>' <dir> and tag -gtf '<tag>' <dir>
            fargs[1]=${fargs[1]/t/}
            targs=( "-Ntf" "${fargs[-2]}" "${fargs[-1]}" )
          } elif [[ $#fargs -eq 2 && $#fst_fargs -eq 2 && $fargs = *m* ]] {
            targs=( "-Ntf" "${fargs[-1]}" "." )
          } else {
            +Ftag::msg -p "{err}only the following tags are supported with garrulous mode:" \
                $'\n'"-{yell}g{res}, -{yell}gl{res}" \
                $'\n'"-{yell}gf{res} '{green}<tag>{res}' {green}<dir>{res}, -{yell}gtf {green}<tag> <dir>{res}"$'\t'"(same output)" \
                $'\n'"-{yell}gf{res} '{green}<tag>{res}', -{yell}gtf {green}<tag>{res}"$'\t'"(same output, global search)" \
                $'\n'"-{yell}gm{res} '{green}<tag>{res}'"$'\t'"(local search)" \
            exit 1
          }
        # Can't use (( )) if tags in unset. Tried [[ ! -v tags ]]
        if [[ $#tags -eq 0 ]] {
            tags=( ${(@f)"$(tag ${(z)targs})"} )
            files=( ${(@f)"$(tag ${(z)fargs})"} )
          }
        }
        ;;
      (*-[[:alpha:]]#m[[:alpha:]]#*|*--match*)
        () {
          emulate -LR zsh
          setopt extendedglob warncreateglobal noksharrays noshortloops nokshglob
          local -a fst_fargs=( ${(s::)${fargs[1]#-}} )
          if [[ $#fargs -eq 1 ]] {
            +Ftag::msg -p "{err}you must supply a tag"
            exit 1
          } elif [[ $#fargs -eq 2 && $#fst_fargs -eq 1 && $fst_fargs = m ]] {
            local -a files=( ${(@f)"$(tag ${(z)fargs})"} )
            print -rl -- ${FTAG[green]}${files}${FTAG[res]}
            return 0
          } elif [[ $#fargs -eq 2 && $#fst_fargs -eq 2 && $fst_fargs[1] = t && $fst_fargs[2] = m ]] {
            # Normal tag requires -m and -f to be last flag since these flags require an argument
            # So, only check for -tm order here
            targs=( "-Ntm" "$fargs[-1]" )
            fargs=( "-Tm"  "$fargs[-1]" )
          } elif [[ $#fargs -eq 3 && $#fst_fargs = <2-3> && ( $fst_fargs[1] = t || $fst_fargs[2] = t ) &&
                ( $fst_fargs[2] = m || $fst_fargs[3] = m )
          ]] {
          # If tag -tm is given a dir along with a path, -e is required to enter directory
          # Here, (( -etm || -tem ) || -tm ) <tag> <dir> will be treated the same
          # Do not quote $~
            targs=( -Netm $fargs[-2] $~fargs[-1] )
            fargs=( -em  $fargs[-2] $~fargs[-1] )
          }
        tags=( ${(@f)"$(tag ${(z)targs})"} )
        files=( ${(@f)"$(tag ${(z)fargs})"} )
        }
        ;;
      (*-[[:alpha:]]#f[[:alpha:]]#*|*--find*)
        # tag -tf '*'
        targs+=( "-Ntf" )
        if [[ $#fargs -eq 3 && $~fargs[-1] = (#s)(\~|\/|.##)*/#* ]]; then
          targs+=( "${fargs[-2]}" "${fargs[-1]}" )
        elif [[ $#fargs -eq 2 && $fargs[-1] = (\*|[[:alnum:]]##) ]]; then
          targs+=( "${fargs[-1]}" )
        else
          +Ftag::msg -p "{err}incorrect tag or path"
          return 1
        fi
        tags=( ${(@f)"$(tag ${(z)targs})"} )
        files=( ${(@f)"$(tag ${(z)fargs})"} )
        ;;
      (*)
        +Ftag::msg -p "{err}flag is not supported"
        return 1
      ;;
    esac
  } || {
    # FZF specific
    if [[ $#fargs -eq 1 && $fargs[1] = -l ]]; then
      tmp=( ${${${(@)${(@f)"$(tag -Al)"}/(#m)([[:space:]]|(#e))/---${MATCH}}//[[:space:]]/}//(#m)---(#e)/--- } )
      tags=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[2]}}} )
      files=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[1]}}} )
    else
      (( ${+fargs[(r)-*f*]} )) && targs+=( "-Ntf" )
      if [[ $#fargs -eq 3 && $fargs[-1] = (*/*|\.) ]]; then
        targs+=( "${fargs[-2]}" "${fargs[-1]}" )
      elif [[ $#fargs -eq 2 && $fargs[-1] = (\*|[[:alnum:]]##) ]]; then
        targs+=( "${fargs[-1]}" )
      fi
      tags=( ${(@f)"$(tag ${(z)targs})"} )
      files=( ${(@f)"$(tag ${(z)fargs})"} )
    fi
  }

  integer i longest=0
  local t
  local -a packs unpacked
  for (( i=1; i<=$#tags; i++ )) {
    packs+=( "${(q)${files[$i]}} ${(q)${tags[$i]}//,/\|}" )
  }

 [[ -n $sort ]] && {
  if [[ "${sort#-s}" = (+|a|asc) ]]; then
    packs=( "${(on)packs[@]}" )
  elif [[ "${sort#-s}" = (++|d|desc) ]]; then
    packs=( "${(On)packs[@]}" )
  else
    +Ftag::msg -p "{warn}use 'd|desc|++' for descending; 'a|asc|+' for ascending"
    exit 1 # Doesn't exit here
  fi
  }

  for t ($packs) {
    unpacked=( "${(Q@)${(z@)t}}" )
    (( $#unpacked[1] > $longest )) && longest=$#unpacked[1]
  }

  for t in "${packs[@]}"; do
    unpacked=( "${(Q@)${(z@)t}}" )
    Ftag::color-tag "$unpacked[2]"
    Ftag::map-short "$unpacked[1]"
    # builtin print -n "${(r:longest+1:: :)${(j:/:)reply[@]}} $REPLY"
    (( NO_COLOR )) && {
      (( GARRULOUS )) && {
      builtin print -n "${unpacked[1]}"$'\n\t'"$unpacked[2]"
      } || builtin print -n "${(r:longest+1:: :)unpacked[1]} $unpacked[2]"
    } || {
      (( GARRULOUS )) && {
      builtin print -n "${SHORT}"$'\n\t'"$REPLY"
      } || builtin print -n "${(r:longest+1:: :)SHORT} $REPLY"
    }
    builtin print
  done

  case $VERBOSE in
    ( <1-> )
      +Ftag::msg -p "{brred}${(l:COLUMNS::=:):-}{res}" \
          "{bgreen}Command:{res} tag -${action} ${fargs[2]:-} ${fargs[3]:-}" ;|
    ( <2-> )
      +Ftag::msg -p "{brblue}${(l:COLUMNS::=:):-}{res}" \
         "{bgreen}Length:{res} $#fargs" ;|
    ( <3-> )
      # Call this here as well as usage above so it's only called when needed
      () {
        builtin emulate -LR zsh -o extendedglob
        local -a gtags=( ${${(@f)"$(tag --usage)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}} )
        local -a ltags=( ${(@u)${(@s:,:)${(@f)"$(tag -Nl)"}}} )
        +Ftag::msg -p "{brblue}${(l:COLUMNS::=:):-}{res}" \
            "{bgreen}Global tags:{res}"
        # Using res does not color all tags
        print -c -- ${FTAG[bold]}${(n)gtags}
        +Ftag::msg -p "{res}{brblue}${(l:COLUMNS::=:):-}{res}" \
            "{bgreen}Local tags:{res}"
        print -c -- ${FTAG[bold]}${(n)ltags}
      }
      ;;
  esac
}
# ]]]

# FUNCTION: OS::notify [[[
# TODO: add option to permanently set notifications
function OS::notify() {
  Ftag::dep "terminal-notifier" && {
      terminal-notifier -title "${2:-Ftag}" -message "${1:-.}"
  } || osascript -e 'display notification "'"$*"'"'
}
# ]]]

# SECTION: == Unused == [[[
# FUNCTION: Ftag::parallel2 [[[
# An attempt to make reloading faster with many tags
# Still learning file descriptors
function Ftag::parallel2() {
  # [[ -o zle ]] && zle -I
  local TFD
  exec {TFD} < <(
      LANG=C sleep $(( 0.005 + ${${${(M)1#@sleep:}:+${1#@sleep:}}:-0} ))
      print -r -- ${1:#(@sleep:*)} "${@[2,-1]}"
  )
  zle -N Ftag::parallel
  zle -w -F "$TFD" Ftag::parallel
  # zle -F "$TFD" Ftag::parallel
}
# ]]]

# FUNCTION: Ftag::parallel [[[
function Ftag::parallel() {
  local -a fds=()
  local fd
  {
    local cmd
    for cmd in $@; do
      exec {fd}< <( eval "$cmd" )
      fds+=( $fd )
    done
  } always {
    for fd in $fds; do
      <&$fd
      exec {fd}<&-
    done
  }
}
# ]]]

# FUNCTION: @Ftag::sched [[[
function @Ftag::sched() {
  zmodload -Fa zsh/sched b:sched
  local AFD
  # sched +0 'Ftag::tag "${wrapper#-W}"'
  sched +1 'Ftag::tag "${(z)tag_arguments}"'
  # sched +1 'echo "hi"'

  AFD=13371337
  exec {AFD}< <(LANG=C command sleep 0.002; builtin print run;)
  command true
  zle -F "$AFD" @Ftag::sched
  zle -F "$AFD" 2>/dev/null
}
# ]]]

# FUNCTION: Ftag::format_length [[[
# Could use to split lines based on $#COLUMN
function Ftag::format_length() {
  builtin emulate -LR zsh
  setopt extendedglob warncreateglobal typesetsilent noshortloops
  integer longest=0 longest_left=0 cur_left_len=0 count=1
  local f
  for f in "${(@)${nfiles:^ntags}}"; do
    [[ -z "$f" ]] && continue
    f="${(Q)f}"

    if (( count ++ %2 != 0 )); then
      [[ "${#f}" -gt "$longest_left" ]] && longest_left="${#f}"
      curr_left_len="${#f}"
    else
      curr_left_len+="${#f}"
      curr_left_len+=1
      [[ "$curr_left_len" -gt "$longest" ]] && longest="$curr_left_len"
    fi
  done

  local answer=""
  count=1
  for a in "${(@)${nfiles:^ntags}}"; do
    [[ -z "$f" ]] && continue
    f="${(Q)f}"

    if (( COLUMNS >= longest )); then
      if (( count ++ % 2 != 0 )); then
        answer+="${(r:longest_left+1:: :)f}"
      else
        answer+="$f"$'\n'
      fi
    else
      answer+="$f"$'\n'
    fi
  done
  REPLY="$answer"
  (( COLUMNS >= longest && count % 2 == 0 )) && REPLY="$REPLY"$'\n'
}
# ]]]

# FUNCTION: Ftag::copy [[[
# Determine copy command
# TODO: use this or no?
function Ftag::copy() {
  if Ftag::dep "pbcopyy" ; then FTAG_COPY="pbcopy"
  elif Ftag::dep "xclip" ; then FTAG_COPY="xclip -sel primary"
  elif Ftag::dep "xsel"  ; then FTAG_COPY="xsel -p"
  fi
}
# ]]]

# FUNCTION: Ftag::cleanup [[[
# TODO: look into named pipes
function Ftag::cleanup() {
  rm -f $current_filter
  return 0
}
# ]]]
# ]]] == END: Unused
# ]]] == END: Helper

# SECTION: == Functions: Actions == [[[
# FUNCTION: Ftag::zoxide [[[
# Switch or query directory with zoxide
function Ftag::zoxide() {
  _ZO_FZF_OPTS="$FZF_DEFAULT_OPTS --prompt ' Zoxide Tag> ' --no-height" zoxide query -i
}
# ]]]

# FUNCTION: Ftag::autojump [[[
# Switch or query directory with autojump
function Ftag::autojump() {
  emulate -LR zsh -o extendedglob
  # Prevent the use of external programs as much as possible
  # autojump -s | tac | awk 'NR>7{print $2}' | fzf --prompt ' Jump Tag> ' --no-height
  builtin print -rl -- ${(Oa)${${(@f)"$(autojump -s)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}}[0,-6]} \
    | fzf --prompt ' Jump Tag> ' --no-height
}
# ]]]

# FUNCTION: Ftag::path::find [[[
# Enter in custom path to switch directories
# TODO: create a prompt to switch paths
function Ftag::path::find() {
  builtin print | fzf --prompt ' Custom Path> ' --no-height --print-query
}
# ]]]

# FUNCTION: Ftag::gitui [[[
# If directory is a git-dir (switch git check to func) then use lazygit or tig
function Ftag::gitui() {
  # gitui -d "${(z)@}" - Freezes -- could add grv
  if Ftag::dep "lazygit"; then lazygit -p "${(z)@}"
  elif Ftag::dep "tig"; then tig -C "${(z)@}"
  fi
}
# ]]]

# FUNCTION: Ftag::wutag [[[
# $1 = directory; $2 = filename; $3 = tag
# Option to use wutag alongside tag with '-w' or wutag alone with '-ww'
function Ftag::wutag() {
  builtin emulate -L zsh -o noshortloops
  local opt=$1; shift
  if [[ $opt = -s ]]; then
    # set
    wutag -d "${1}/" clear "$2"
    wutag -d "${1}/" set "$2" "$3"
  elif [[ $opt = -a ]]; then
    # add
    wutag -d "${1}/" set "$2" "$3"
  elif [[ $opt = -r ]]; then
    # remove
    wutag -d "${1}/" rm "$2"
  fi
}
# ]]]

# FUNCTION: Ftag::RG [[[
# Open directory and interactively search with ripgrep
# Default action is to open in editor
# TODO: add options to fzf
function Ftag::RG() {
  emulate -LR zsh -o extendedglob
  local RG_PREFIX INITIAL_QUERY
  local -a selected opts
  # zpty -e RG FZF_DEFAULT_COMMAND="$RG_PREFIX '$INITIAL_QUERY' || true"
  RG_PREFIX="rg --column --hidden --line-number --no-heading --color=always --smart-case "
  INITIAL_QUERY="${*:-}"
  (
    selected=("$(
      FZF_DEFAULT_COMMAND="$RG_PREFIX '$INITIAL_QUERY' || true" \
        fzf --bind "change:reload:$RG_PREFIX {q} || true" \
          --ansi --disabled --query "$INITIAL_QUERY" \
          --delimiter : \
          --bind 'ctrl-e:execute($EDITOR "$(echo {} | cut -d: -f1)" >/dev/tty </dev/tty)' \
          --bind='ctrl-y:execute-silent(echo {+} | cut -d: -f1 | pbcopy)' \
          --preview 'bat --style=numbers,header,changes,snip --color=always --highlight-line {2} {1}' \
          --preview-window 'default:right:60%:~1:+{2}+3/2:border-left'
    )")
    selected=( ${(@s.:.)selected} )
    [[ -n "${selected[1]}" ]] && ${EDITOR} "${selected[1]}" "+${selected[2]}"
  )
}
# ]]]

# FUNCTION: Ftag::gpg [[[
# Open and edit an encrypted file (-e)
# Default is to encrypted if decrypted or vice versa
function Ftag::gpg() {
  builtin emulate -L zsh
  setopt extendedglob typesetsilent noshortloops
  local -a mime opts
  local tmpfile
  zparseopts -a opts -D ${(s::):-e}
  zmodload -Fa zsh/files b:zf_rm b:zf_mv
  # TODO: add option for multiple files
  trap "zf_rm -f $tmpfile >/dev/null" EXIT INT TERM
  tmpfile="${TMPDIR:-/tmp}/ftag.dump.$RANDOM"
  mime=( ${(@s./.)${(f)$(file --mime-type --brief "${(z)@}")}} )
  matched=${(M)mime[@]:#(#i)*pgp-encrypted*}
  # Prevent adding armor if user prefers binary encryption
  # If encrypted and edit
  if [[ -n "${matched}" ]] && (( ${+opts[(r)-e]} )) {
    gpg -dq "${(z)@}" > "$tmpfile"
    "${EDITOR:-vim}" "$tmpfile"
    gpg -eq "$tmpfile"
    [[ -f "${tmpfile}.asc" ]] && zf_mv "${tmpfile}.asc" "${(z)@}"
    [[ -f "${tmpfile}.gpg" ]] && zf_mv "${tmpfile}.gpg" "${(z)@}"
    zf_rm -f "$tmpfile"
  # If encrypted, decrypt it
  } elif [[ -n "${matched}" ]] {
    gpg -dq "${(z)@}" > "$tmpfile"
    zf_mv "$tmpfile" "${(z)@}"
  # If decrypted and edit
  } elif [[ -z "${matched}" ]] && (( ${+opts[(r)-e]} )) {
    "${EDITOR:-vim}" "${(z)@}"
  # If decrypted, encrypt it
  } else {
    gpg -eq "${(z)@}"
    [[ -f "${(z)@}.asc" ]] && zf_mv "${(z)@}.asc" "${(z)@}"
    [[ -f "${(z)@}.gpg" ]] && zf_mv "${(z)@}.gpg" "${(z)@}"
  }
}
# ]]]

# FUNCTION: Ftag::twf [[[
# Open directory in twf (similar to fzf)
function Ftag::twf() {
  builtin emulate -L zsh -o extendedglob -o noshortloops
  local -a opts
  local prev file
  prev=${${(M)FTAG_PAGER:#bat*}:-cat}
  zparseopts -a opts -D ${(s::):-es}
  if (( ${+opts[(r)-e]} )); then
    file=$(twf -dir "${(z)@}" -previewCmd "${prev} {}")
    [[ -n "$file" ]] && ${EDITOR:-vim} "$file"
  # TODO: use or delete
  elif (( ${+opts[(r)-s]} )); then
    twf -dir "${(z)@}" -previewCmd "${prev} {}"
  fi
}
# ]]]

# FUNCTION: Ftag::dua [[[
# Open directory in dua interactively
function Ftag::dua() {
  builtin emulate -LR zsh
  if Ftag::dep "dua"; then
    dua i "$@"
  elif Ftag::dep "ncdu"; then
    ncdu "$@"
  else
    return 1
  fi
}
# ]]]

# FUNCTION: Ftag::forgit [[[
# Open directory if git and use forgit
function Ftag::forgit() {
  builtin emulate -L zsh -o extendedglob
  zmodload -Fa zsh/parameter p:functions
  local -A forgit_cmds
  forgit_cmds=(
    add              "forgit::add"
    log              "forgit::log"
    diff             "forgit::diff"
    ignore           "forgit::ignore"
    reset_head       "forgit::reset::head"
    checkout_file    "forgit::checkout::file"
    checkout_branch  "forgit::checkout::branch"
    checkout_commit  "forgit::checkout::commit"
    clean            "forgit::clean"
    stash            "forgit::stash::show"
    cherry-pick      "forgit::cherry::pick"
    rebase_i         "forgit::rebase"
    fixup            "forgit::fixup"
  )
  Ftag::dep "dotbare" || return 1
  Ftag::is_git "$@" &>/dev/null || local git="no"
  if [[ $git != "no" ]]; then
    local reply wfxr
    wfxr=${(f)$(whence -va forgit::log)}

    # If used as a function and not autoloaded
    if [[ -f "$wfxr" ]]; then
      builtin source "$wfxr"
    elif [[ -f ${ZDOTDIR:-$HOME}/.zinit/plugins//wfxr---forgit/forgit.plugin.zsh ]]; then
      builtin source "${ZDOTDIR:-$HOME}/.zinit/plugins//wfxr---forgit/forgit.plugin.zsh"
    elif [[ -f ${ZDOTDIR:-$HOME}/.zplugin/plugins//wfxr---forgit/forgit.plugin.zsh ]]; then
      builtin source "${ZDOTDIR:-$HOME}/.zplugin/plugins//wfxr---forgit/forgit.plugin.zsh"
    elif [[ -f ${ZDOTDIR:-$HOME}/zinit/plugins//wfxr---forgit/forgit.plugin.zsh ]]; then
      builtin source "${ZDOTDIR:-$HOME}/zinit/plugins//wfxr---forgit/forgit.plugin.zsh"
    elif [[ -f ${ZDOTDIR:-$HOME}/.ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh ]]; then
      builtin source "${ZDOTDIR:-$HOME}/.ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh"
    elif [[ -f ${ZDOTDIR:-$HOME}/ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh ]]; then
      builtin source "${ZDOTDIR:-$HOME}/ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh"
    elif [[ -z $ZDOTDIR && -f $HOME/.zshrc ]]; then
      builtin source $HOME/.zshrc
    elif [[ -f ${ZDOTDIR:-$HOME/.config/zsh}/.zshrc ]]; then
      builtin source ${ZDOTDIR:-$HOME/.config/zsh}/.zshrc
    fi

    reply=$(print -rl "${(@k)forgit_cmds}" | fzf --no-height)
    [[ -n "$reply" ]] && {
      (( ${+functions[${forgit_cmds[$reply]}]} )) && \
      FORGIT_FZF_DEFAULT_OPTS="$FORGIT_FZF_DEFAULT_OPTS --no-height" $forgit_cmds[$reply]
    } || OS::notify "Selected function is unavailable" && return 1
  else
      OS::notify "Not a git directory"
  fi
}
# ]]]

# FUNCTION: Ftag::dotbare [[[
# If dir is git use dotbare in that dir; else use on dotfiles
# Brings up own interactive menu
function Ftag::dotbare() {
  builtin emulate -L zsh -o extendedglob
  local -a choice action
  local final
  Ftag::dep "dotbare" || return 1
  Ftag::is_git "$@" &>/dev/null || local git="no"
  if [[ $git != "no" ]]; then
    () { setopt localoptions noautopushd; builtin cd -q "${~@}"; } "$@" || return 1
    # setopt localoptions noautopushd
    # builtin cd -q "${~@}" || return 1
    choice=( ${(@f)"$(dotbare)"} )
    action=( ${(@z)choice[1]} )
    final=${action[$(( ${action[(I)dotbare]} + 1 ))]}
    dotbare --git "$final"
  else
    choice=( ${(@f)"$(dotbare)"} )
    action=( ${(@z)choice[1]} )
    final=${action[$(( ${action[(I)dotbare]} + 1 ))]}
    dotbare "$final"
  fi
}
# ]]]

# FUNCTION: Ftag::glow [[[
# Open directory to browse markdown files
function Ftag::glow() {
  integer mdfiles
  mdfiles=$(fd . -e md -d1 "${~@}" | wc -l)
  (( mdfiles > 0 )) && {
    glow "${~@}"; return 0
  } || return 1
}
# ]]]
# ]]] == END: Functions: Actions

# == SECTION: Functions: Formatting and Display == [[[
# FUNCTION: Ftag::default_header [[[
# Default header displayed on commands asking for input
# Sub-Zero // ansi_shadow / ANSI_regular / big / doom / small / standard
function Ftag::default_header() {
  emulate -LR zsh -o extendedglob
  local -a fig; integer max color; local -A string
  # Not max, but it works
  zparseopts -D -- s:=string c::=color
  fig=( ${(@f)"$(figlet -f ${FZFTAG_FONT:-standard} ${(v)string[(e)-s]} )"} )
  max=${#${(On)fig}[1]}
  print -nPr "%F{${${color#-c}:-2}}"
  print -lr -- "${(l:(( (COLUMNS+max)/2 )):: :)fig[@]}"
  print -Prn "%f"
  print -Pr -- "%F{1}${(l:COLUMNS::=:):-}%f"
}
# ]]]

# FUNCTION: Ftag::boxes [[[
# Format header display from CLI
function Ftag::boxes() {
  (( ${+commands[boxes]} )) && boxes -d tex-box || {
    cat; +Ftag::msg -p "{warn}{green}boxes{res} is required to use this feature{res}"
  }
}
# ]]]
# FUNCTION: Ftag::lolcat [[[
function Ftag::lolcat() {
  (( ${+commands[lolcat]} )) && lolcat || {
    cat; +Ftag::msg -p "{warn}{green}lolcat{res} is required to use this feature{res}"
  }
}
# ]]]
# FUNCTION: Ftag::toilet [[[
function Ftag::toilet() {
  # smblock smmono12
  # toilet -f smmono12 -F border --filter gay
  (( ${+commands[toilet]} )) && {
    toilet -d "${prog_dir}/../fonts" -f ansi_shadow --gay "${(j. .)@}"
  } || {
    cat; +Ftag::msg -p "{warn}{green}toilet{res} is required to use this feature{res}"
  }
}
# ]]]

# FUNCTION: Ftag::parse_format [[[
# Display with either toilet, lolcat, or boxes
function Ftag::parse_format() {
  builtin emulate -LR zsh
  setopt noshortloops noksharrays
  # Toilet:
  if (( FZFTAG_TOILET )); then
    if (( FZFTAG_LOLCAT )); then
      if (( FZFTAG_BOXES )); then
        Ftag::toilet "${(j. .)@}" | Ftag::boxes | Ftag::lolcat
      else
        Ftag::toilet "${(j. .)@}" | Ftag::lolcat          # tc
      fi
    else
      Ftag::toilet "${(j. .)@}"                           # t
    fi
  # Figlet:
  elif (( FZFTAG_LOLCAT )); then
      if (( FZFTAG_BOXES )); then
        $figlet "${(j. .)@}" | Ftag::boxes | Ftag::lolcat # cb
      else
        $figlet "${(j. .)@}" | Ftag::lolcat               # c
      fi
  elif (( FZFTAG_BOXES )); then
      $figlet "${(j. .)@}" | Ftag::boxes                  # b
  else
    Ftag::default_header -s "${(j. .)@}" -c 2             # default
  fi
}
# ]]]

# FUNCTION: Ftag::vared-format [[[
# Display tags for 'vared' in the main loop
#             
#  ❱ ❯  ⎣1⎤ ❪1❫ ⟦1⟧  ◂▸
# (->|=>|→)
function Ftag::vared-format() {
  builtin emulate -LR zsh
  setopt extendedglob noshortloops warncreateglobal
  integer adjusted i=1 max=0
  local -a formatted tags tmp; formatted=()
  # local t f; for f (${(@f)@}) { (( $#f > $max )) && max=$#f }
  local t f; for f in "${(@f)${@}}"; do [[ "${#f}" -gt $max ]] && max="${#f}"; done
  adjusted=$(( ${#FTAG[res]} * 2 + ${#FTAG[bcyan]} + ${#FTAG[green]} ))
  for f in "${@}"; do

    formatted=( "${i:+${FTAG[bcyan]}❪$(( i ++ ))❫ ▸${FTAG[res]}} ${f:+${FTAG[green]}${f//\%/%%}${FTAG[res]}}" )
    # tmp=( ${(@s:,:)${${(s:---:)${${(@f)"$(tag -Al $f)"}//[[:space:]]##/---}}[2]}} )
    Ftag::map-back "$f"
    tmp=( ${(s:,:)${(@f)$(tag -Al "$reply")[2]}} )
    tags=()

    for t in "${tmp[@]}"; do
      tags+=( "${t:+${FTAG[byell]} ${FTAG[res]}${FTAG[bmagen]}${t}${FTAG[res]}}" )
    done

    print -rl -- ${(l:max+adjusted+7+1+5:)${(r:max+adjusted+7+1:)formatted[@]}}
    print -rl -- ${(l:max+adjusted+7+1+5+4:)${(r:max+adjusted+7+1:)tags[@]}}

  done
  # print -rl -- ${(l:max+adjusted+7+1+5:)${(r:max+adjusted+7+1:)formatted[@]}}
}
# ]]]
# ]]] == END: Formatting and Display

# ARRAYS: Bindings [[[
local -a __FTAG_EXTERNAL_OPTS
__FTAG_EXTERNAL_OPTS=(
    wutag zoxide autojump lolcat toilet boxes tag fzf glow lazygit gitui gpg
    dua twf dotbare forgit rg bat ftag less pbcopy ctrl alt lf ranger xplr exa
    dragon
)

local -A __FTAG_OPTS
__FTAG_OPTS=(
    "-w, --wutag"         "Also tag files with wutag (-ww only uses wutag)"
    "-q, --query <query>" "Start fzf with a query"
    "-p, --path"          "Enter a path for ftag to start"
    "-z, --zoxide"        "Use zoxide to select directory to use tags (only shows tagged files)"
    "-j, --autojump"      "Use autojump to select directory to use tags (only shows tagged files)"
    "-b, --boxes"         "Add a box around header with boxes"
    "-c, --lolcat"        "Color the header with lolcat"
    "-t, --toilet"        "Color and format the header with toilet"
    "-l, --local"         "Use tag in a local directory"
    "-n, --nocolor"       "Don't use colored output"
    "-s, --sort"          "Sort desc with d|desc|++, sort ascending with a|asc|+"
    "-N, --nofzf"         "No fzf, however not a wrapper"
    "-W, --wrapper"       "No fzf, but is a wrapper and can use tag commands"
    "-f, --cfont"         "Use custom font with figlet (some are provided)"
    "-h, --help"          "Display this help message"
    "-v, --verbose"       "Display verbosity (-vvv is max; only used with wrapper as of now)"
)

local -A __FTAG_KEYBINDINGS
__FTAG_KEYBINDINGS=(
    A   "Add/append tags -- ACTION_ADD"
    S   "Set tags (overwrites) -- ACTION_SET"
    D   "Delete/remove tags -- ACTION_REMOVE"
    R   "Reload the tag search -- ACTION_RELOAD"
    U   "Show tag usage -- ACTION_USAGE"
    E   "Edit selected tags with \$EDITOR -- ACTION_EDIT"
    F   "Open directory with file manager in which tagged file resides -- ACTION_FILEMANAGER"
    C-w "Open directory with glow if dir contains markdown files -- ACTION_GLOW"
    I   "Open gitui/lazygit if directory is a git-dir -- ACTION_GIT"
    C-p "Switch to custom path -- ACTION_PATH"
    L   "Switch to local mode (i.e., current directory) -- ACTION_LOCAL"
    G   "Switch to global mode (i.e., default mode/all tags on filesystem) -- ACTION_GLOBAL"
    Z   "Switch to zoxide query to select path to list tags -- ACTION_ZOXIDE"
    J   "Switch to autojump query to select path to list tags -- ACTION_AUTOJUMP"
    C-p "Open a popup window to copy file with dragon -- ACTION_DRAGON_SOURCE"
    C-e "Edit a gpg-encrypted file -- ACTION_GPG_EDIT"
    C-g "Encrypt or decrypt a file with gpg. If encryped, decrypted and vice versa -- ACTION_GPG"
    C-d "Open directory in dua interactive mode -- ACTION_DUA"
    C-t "Open directory in twf to edit file -- ACTION_TWF_EDIT"
    C-r "Open directory with rg in an interactive mode -- ACTION_RIPGREP"
    C-f "If git-dir, open forgit to select action -- ACTION_FORGIT"
    C-b "If git-dir, open dotbare to select action -- ACTION_DOTBARE"
    C-o "Open directory in finder -- ACTION_FINDER"
    O   "Open file in external program based on extension -- ACTION_OPEN"
    M-d "Be propted to delete file -- ACTION_DELETE"
    P   "Toggle preview of file or directory -- ACTION_PREVIEW"
    V   "Toggle bat to view file -- ACTION_VIEW"
    C-v "Toggle a TUI program to view file -- ACTION_EXTERNALVIEW"
    C-y "Copy file or directory name -- ACTION_COPY"
    Q   "Quit ftag -- ACTION_QUIT"
    "?" "Show key help message -- ACTION_HELP"
)

typeset -gAH __FTAG_ENVIRONVARS
__FTAG_ENVIRONVARS=(
    FTAG_PAGER       'Pager to view file or usage (default: bat, less)'
    FTAG_COPY        'Copy command to copy path to clipboard (default: pbcopy)'
    FTAG_MODIFIER    'Modifier to bind with fzf (default: ctrl)'
    FTAG_ALT         'Alternative key bind with fzf (default: alt)'
    FTAG_FILEMANAGER 'File manager to open in ftag (default: lf, ranger, xplr)'
    FTAG_FILE_PREV   'Fzf preview for files (default: bat)'
    FTAG_DIR_PREV    'Fzf preview for directories (default: exa)'
)
# ]]]

# FUNCTION: Ftag::usage [[[
# Display typical help message
function Ftag::usage() {
  emulate -LR zsh
  builtin setopt extendedglob noshortloops noksharrays rcquotes
  Ftag::default_header -s "ftag" -c 13
  +Ftag::msg -p "{bred}USAGE:{res}"
  +Ftag::msg -p $'\t'"{brcyan}ftag{res} {brmagen}[wsh]{res} {green}<tag>{res}" \
                $'\n\t'"{green}ftag{res} is an FZF TUI for jdberry's {green}tag{res} on macOS" \
                $'\n\t'"It uses {yell}figlet{res} by default to display headers, though it is not needed" \
                $'\n\t'"{green}<tag>{res} is an optional argument, and if used it must be exact. There" \
                $'\n\t'"are zsh completions to help complete tags. For a fuzzy search, use the {green}--q{res} flag"
  +Ftag::msg -p "{bred}FLAGS:{res}"

  # Fix these to be one command
  local THEFD
  {
    exec {THEFD} < <(
      integer longest=0
      local k v
      for k (${(@ok)__FTAG_OPTS}) { (( $#k > $longest )) && longest=$#k }
      adjusted=$(( ${#FTAG[res]} * 2 +  ${#FTAG[green]} * 2 ))
      for k in ${(@ok)__FTAG_OPTS}; do
        # Detect if by a comma
        print -r -- $'\t'${(r:longest+adjusted+4:: :)${(j:, :)${${(s:, :)k[@]}//(#m)*/${FTAG[green]}${MATCH}${FTAG[res]}}}} \
          ${${__FTAG_OPTS[$k]}//(#b)(${(~j:|:)__FTAG_EXTERNAL_OPTS}|-[a-z]##) /${FTAG[yell]}${match[1]}${FTAG[res]} }
      done
    )
  } always {
    <&$THEFD
    exec {THEFD}<&-
  }

  +Ftag::msg -p $'\t'"The above flags can be used in any combination. Figlet is ran if toilet isn't" \
                $'\n\t'"specified and vice-versa. Figlet cannot be specified explicitly. The default" \
                $'\n\t'"printing (no flags specified and figlet installed) looks the nicest."
  +Ftag::msg -p "{bred}INSIDE FZF:{res}"
  Ftag::parallel "Ftag::show_keys"
}
# ]]]

# FUNCTION: Ftag::show_keys [[[
# Display keybindings within fzf
function Ftag::show_keys() {
  emulate -LR zsh
  builtin setopt extendedglob noshortloops noksharrays rcquotes
  integer longest=0
  local k v; for v (${(@ok)__FTAG_KEYBINDINGS}) { (( $#v > $longest )) && longest=$#v; }
  adjusted=$(( ${#FTAG[res]} +  ${#FTAG[green]} ))
  for k in ${(@ok)__FTAG_KEYBINDINGS}; do
    print -r -- $'\t'${(r:longest+adjusted+4:)${k:+${FTAG[green]}${k}${FTAG[res]}}} \
      ${${${__FTAG_KEYBINDINGS[$k]}//(#b)(${(~j:|:)__FTAG_EXTERNAL_OPTS})/${FTAG[yell]}${match}${FTAG[res]}}//-- (#m)ACTION_*/${FTAG[brcyan]}${MATCH##--}${FTAG[res]}}
  done
  Ftag::parallel "Ftag::env_vars"
}
# ]]]

# FUNCTION: Ftag::env_vars [[[
# Display environment variables for ftag
function Ftag::env_vars() {
  emulate -LR zsh
  builtin setopt extendedglob noshortloops noksharrays rcquotes
  +Ftag::msg -p "{bred}ENVIRONMENT VARIABLES:{res}"
  integer longest=0
  local k v; for v (${(@ok)__FTAG_ENVIRONVARS}) { (( $#v > $longest )) && longest=$#v; }
  adjusted=$(( ${#FTAG[res]} + ${#FTAG[green]} ))
  for k in ${(@ok)__FTAG_ENVIRONVARS}; do
    print -r -- $'\t'${(r:longest+adjusted+4:)${k:+${FTAG[magen]}${k}${FTAG[res]}}} \
      ${${__FTAG_ENVIRONVARS[$k]}//(#b)(${(~j:|:)__FTAG_EXTERNAL_OPTS})/${FTAG[yell]}${match[1]}${FTAG[res]}}
  done
}
# ]]]
# ]]] == END: Functions: Formatting and Display

# SECTION: == Imports / Setting Variables == [[[
zmodload -Fa zsh/zutil b:zparseopts \
  || +Ftag::msg -p "{err}{green}zsh/zutil{res} is required to use this program{res}"
# ${commands[@]} array
zmodload -Fa zsh/parameter p:commands p:parameters \
  || +Ftag::msg -p "{err}{green}zsh/parameter{res} is requred to use this program{res}"
# tput $COLUMNS
zmodload zsh/terminfo 2>/dev/null
zmodload zsh/termcap 2>/dev/null

# a all = not used
# Set query as optional args to prevent errors
local -A opts
local -a cfont sort wtag query verbose
typeset -gaH wrapper
zparseopts -D -A opts h -help b -boxes c -lolcat t -toilet \
    l -local z -zoxide j -jump n -nocolor N -nofzf {W,-wrapper}:=wrapper \
    {f,-font}::=cfont {p,-path}:=opts {q,-query}::=query \
    {w,-wutag}+=wtag {s,-sort}::=sort {v,-verbose}+=verbose

# colors=(); fg=(); bg=(); fg_bold=(); bg_bold=(); reset_color=""
typeset -gAH FTAG
FTAG=(
  red    $'\e[38;5;1m'  bred   $'\e[01;31m' brred   $'\e[38;5;9m'
  green  $'\e[38;5;2m'  bgreen $'\e[01;32m' brgreen $'\e[38;5;10m'
  yell   $'\e[38;5;3m'  byell  $'\e[01;33m' bryell  $'\e[38;5;11m'
  blue   $'\e[38;5;4m'  bblue  $'\e[01;34m' brblue  $'\e[38;5;12m'
  magen  $'\e[38;5;5m'  bmagen $'\e[01;35m' brmagen $'\e[38;5;13m'
  cyan   $'\e[38;5;6m'  bcyan  $'\e[01;36m' brcyan  $'\e[38;5;14m'
  und    $'\e[4m'       bold   $'\e[1m'
  res    $'\e[0m'
)

typeset -gAH __FTAG_ANSI
__FTAG_ANSI=(
  red   "$fg_no_bold[red]"     bred   "$fg_bold[red]"     bgred   "$bg[red]"
  green "$fg_no_bold[green]"   bgreen "$fg_bold[green]"   bggreen "$bg[green]"
  yell  "$fg_no_bold[yellow]"  byell  "$fg_bold[yellow]"  bgyell  "$bg[yellow]"
  blue  "$fg_no_bold[blue]"    bblue  "$fg_bold[blue]"    bgblue  "$bg[blue]"
  magen "$fg_no_bold[magenta]" bmagen "$fg_bold[magenta]" bgmagen "$bg[magenta]"
  cyan  "$fg_no_bold[cyan]"    bcyan  "$fg_bold[cyan]"    bgcyan  "$bg[cyan]"
)

Ftag::declare -A '\
  FTAG_DIR_MAP=(
    "$HOME/.config/zsh"     %ZDOTDIR
    "$HOME/.config"         %XDG_CONFIG_HOME
    "$HOME/.cache"          %XDG_CACHE_HOME
    "$HOME/.local/share"    %XDG_DATA_HOME
    "$HOME/bin"             %XDG_BIN_HOME
    "$HOME/ghq"             %GHQ
    "$HOME/github"          %GITHUB
    "$HOME/projects/github" %GITHUB
    "$HOME/Downloads"       %DOWNLOADS
    "$HOME/Documents"       %DOCUMENTS
    "$HOME/Desktop"         %DESKTOP
    "$HOME/Pictures"        %PICTURES
    "$HOME/Library"         %LIBRARY
    "$HOME/Applications"    %APPLICATIONS
    "$HOME/Music"           %MUSIC
    "$HOME/Movies"          %MOVIES
    "$HOME/vimwiki"         %WIKI_DIR
    "$HOME"                 %HOME
  )'

# Has to be global when program is sourced on second loop
typeset -gH FZFTAG_QUERY
FZFTAG_QUERY=${${(v)opts[(I)(-q|--query)]}:-}  # fzf query
export FZFTAG_QUERY

typeset -gH FZFTAG_PATH
FZFTAG_PATH=${${(v)opts[(I)(-p|--path)]}:-}  # search path
export FZFTAG_PATH

typeset -g +h LESS
local space
space="[[:space:]]#"
# Prevent -r from being added twice; -F prevents paging if less than screen size
LESS=${(j. .)${${(@)${(s: :)LESS}}//(${~space}-r${~space}|${~space}-F${~space})/}}
export LESS="-r $LESS"

Ftag::opts "h help" && {
  Ftag::usage
  exit 0
}

local figlet
Ftag::dep -e "tag"
Ftag::dep "figlet" && figlet="figlet" || figlet="cat"
# ]]] == END: Setting Variables

# SECTION: == Config == [[[
Ftag::declare "FTAG_PAGER=${${${commands[bat]}:+bat --paging=always -f}:-less}"
Ftag::declare "FTAG_FILEMANAGER=${commands[lf]:-${commands[ranger]}:-${commands[xplr]}}"
Ftag::declare "FTAG_MODIFIER=ctrl"
Ftag::declare "FTAG_ALT=alt"
Ftag::declare "FTAG_COPY=pbcopy"

readonly TTY_REDIRECTION="< /dev/tty > /dev/tty 2>&1"
readonly FTAG_PRINT="+print-query"
readonly FTAG_INTERNAL="+reload(env _FZFTAG_INTERNAL=reload $prog)"
readonly FTAG_RELOAD="+reload(env _FZFTAG_RELOAD=true $prog)"
readonly FTAG_CHPROMPT="+change-prompt"

# Fzf reloads automatically when locally searching
# However global requires a manual reload unless you wait just a second
# The redirection, reload, and print seems to help some

# FTAG_ACTIONS[ACTION_ADD]="execute(env FZFTAG_ACTION=add $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}${(z)FTAG_INTERNAL}"
# FTAG_ACTIONS[ACTION_REMOVE]="execute(env FZFTAG_ACTION=remove $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}${(z)FTAG_INTERNAL}"
# FTAG_ACTIONS[ACTION_VIEW]="execute(bat --style=header,snip -f --paging=always {1} )"

typeset -gA FTAG_ACTIONS
: ${FTAG_ACTIONS[ACTION_ADD]:="execute(env FZFTAG_ACTION=add $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_SET]:="execute(env FZFTAG_ACTION=set $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_EDIT]:="execute(env FZFTAG_ACTION=edit $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_REMOVE]:="execute(env FZFTAG_ACTION=remove $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_USAGE]:="execute(env FZFTAG_ACTION=usage $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}

: ${FTAG_ACTIONS[ACTION_FILEMANAGER]:="execute(env FZFTAG_ACTION=file-manager $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_GIT]:="execute(env FZFTAG_ACTION=git $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_GPG_EDIT]:="execute(env FZFTAG_ACTION=gpg-edit $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_GPG]:="execute(env FZFTAG_ACTION=gpg $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_DUA]:="execute(env FZFTAG_ACTION=dua $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_TWF_EDIT]:="execute(env FZFTAG_ACTION=twf-edit $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_RIPGREP]:="execute(env FZFTAG_ACTION=ripgrep $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_FORGIT]:="execute(env FZFTAG_ACTION=forgit $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_DOTBARE]:="execute(env FZFTAG_ACTION=dotbare $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_GLOW]:="execute(env FZFTAG_ACTION=glow $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_DRAGON_SOURCE]:="execute(env FZFTAG_ACTION=dragon-source $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}

: ${FTAG_ACTIONS[ACTION_FINDER]:="execute(env FZFTAG_ACTION=open-finder $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_OPEN]:="execute(env FZFTAG_ACTION=open $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_VIEW]:="execute(env FZFTAG_ACTION=bat-view $prog {+f})"}
: ${FTAG_ACTIONS[ACTION_EXTERNALVIEW]:="execute(env FZFTAG_ACTION=external-view $prog {+f})"}
: ${FTAG_ACTIONS[ACTION_COPY]:="execute-silent(env FZFTAG_ACTION=copy $prog {+f})"}
: ${FTAG_ACTIONS[ACTION_DELETE]:="execute(env FZFTAG_ACTION=delete $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}

: ${FTAG_ACTIONS[ACTION_LOCAL]:="execute(env FZFTAG_STATE_CHANGE=local $prog )${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}( Local Tag> )"}
: ${FTAG_ACTIONS[ACTION_PATH]:="execute(env FZFTAG_STATE_CHANGE=path $prog )${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}( Path Tag> )"}
: ${FTAG_ACTIONS[ACTION_GLOBAL]:="execute(env FZFTAG_STATE_CHANGE=global $prog )${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}( Global Tag> )"}
: ${FTAG_ACTIONS[ACTION_ZOXIDE]:="execute(env FZFTAG_STATE_CHANGE=zoxide $prog )${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}( Zoxide Tag> )"}
: ${FTAG_ACTIONS[ACTION_AUTOJUMP]:="execute(env FZFTAG_STATE_CHANGE=autojump $prog )${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}( Jump Tag> )"}

: ${FTAG_ACTIONS[ACTION_RELOAD]:="reload(env _FZFTAG_INTERNAL=reload $prog)"}
: ${FTAG_ACTIONS[ACTION_PREVIEW]:="toggle-preview"}
: ${FTAG_ACTIONS[ACTION_HELP]:="execute(env _FZFTAG_SHOW=keys $prog | ${(z)FTAG_PAGER} )${(z)FTAG_PRINT}"}
: ${FTAG_ACTIONS[ACTION_QUIT]:="abort"}

: ${FTAG_ACTIONS[ACTION_TEST]:="execute(env FZFTAG_ACTION=test $prog {+f} ${(z)TTY_REDIRECTION})${(z)FTAG_PRINT}"}

# TODO: use or remove
: ${FTAG_ACTIONS[ACTION_TWF_SWITCH]:="execute(env FZFTAG_STATE_CHANGE=twf-switch $prog )${(z)FTAG_RELOAD}${FTAG_CHPROMPT}(TWF Tag>)"}

# TODO: create page explaining fzf executes to allow these

# zstyle ':ftag:*' keyfile $XDG_CONFIG_HOME/bat/config
# FTAG_KEYFILE="test"
# [[ ! -v FTAG_KEYBINDINGS ]]

typeset -gHA __ftag_config

local z_keyfile l_keyfile
zstyle -s ':ftag:*' keyfile z_keyfile && __ftag_config[keyb]=$z_keyfile || {
  ! Ftag::declare "FTAG_KEYFILE=${XDG_CONFIG_HOME:-$HOME/.config}/ftag/config" && __ftag_config[keyb]=$FTAG_KEYFILE || {
    __ftag_config[keyb]=${0:A}
  }
}

# [[ $__ftag_config[keyb] != ${0:A} && ! -v FTAG_KEYBINDINGS ]] && builtin source $__ftag_config[keyb] || { ... }

zstyle :plugin:ftag bindings default
typeset -gA FTAG_KEYBINDINGS
: ${FTAG_KEYBINDINGS[A]:=$FTAG_ACTIONS[ACTION_ADD]}
: ${FTAG_KEYBINDINGS[S]:=$FTAG_ACTIONS[ACTION_SET]}
: ${FTAG_KEYBINDINGS[E]:=$FTAG_ACTIONS[ACTION_EDIT]}
: ${FTAG_KEYBINDINGS[D]:=$FTAG_ACTIONS[ACTION_REMOVE]}
: ${FTAG_KEYBINDINGS[U]:=$FTAG_ACTIONS[ACTION_USAGE]}
: ${FTAG_KEYBINDINGS[T]:=$FTAG_ACTIONS[ACTION_TEST]}
: ${FTAG_KEYBINDINGS[F]:=$FTAG_ACTIONS[ACTION_FILEMANAGER]}
: ${FTAG_KEYBINDINGS[I]:=$FTAG_ACTIONS[ACTION_GIT]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-b]:=$FTAG_ACTIONS[ACTION_DOTBARE]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-f]:=$FTAG_ACTIONS[ACTION_FORGIT]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-e]:=$FTAG_ACTIONS[ACTION_GPG_EDIT]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-g]:=$FTAG_ACTIONS[ACTION_GPG]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-d]:=$FTAG_ACTIONS[ACTION_DUA]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-t]:=$FTAG_ACTIONS[ACTION_TWF_EDIT]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-r]:=$FTAG_ACTIONS[ACTION_RIPGREP]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-o]:=$FTAG_ACTIONS[ACTION_FINDER]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-w]:=$FTAG_ACTIONS[ACTION_GLOW]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-p]:=$FTAG_ACTIONS[ACTION_DRAGON_SOURCE]}
: ${FTAG_KEYBINDINGS[O]:=$FTAG_ACTIONS[ACTION_OPEN]}
: ${FTAG_KEYBINDINGS[${FTAG_ALT}-d]:=$FTAG_ACTIONS[ACTION_DELETE]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-p]:=$FTAG_ACTIONS[ACTION_PATH]}
: ${FTAG_KEYBINDINGS[L]:=$FTAG_ACTIONS[ACTION_LOCAL]}
: ${FTAG_KEYBINDINGS[G]:=$FTAG_ACTIONS[ACTION_GLOBAL]}
: ${FTAG_KEYBINDINGS[Z]:=$FTAG_ACTIONS[ACTION_ZOXIDE]}
: ${FTAG_KEYBINDINGS[J]:=$FTAG_ACTIONS[ACTION_AUTOJUMP]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-y]:=${(z)FTAG_ACTIONS[ACTION_COPY]}}
: ${FTAG_KEYBINDINGS[V]:=$FTAG_ACTIONS[ACTION_VIEW]}
: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-v]:=$FTAG_ACTIONS[ACTION_EXTERNALVIEW]}
: ${FTAG_KEYBINDINGS[R]:=$FTAG_ACTIONS[ACTION_RELOAD]}
: ${FTAG_KEYBINDINGS[P]:=$FTAG_ACTIONS[ACTION_PREVIEW]}
: ${FTAG_KEYBINDINGS[Q]:=$FTAG_ACTIONS[ACTION_QUIT]}
: ${FTAG_KEYBINDINGS[esc]:=$FTAG_ACTIONS[ACTION_QUIT]}    # ??
: ${FTAG_KEYBINDINGS[?]:=$FTAG_ACTIONS[ACTION_HELP]}

: ${FTAG_KEYBINDINGS[${FTAG_MODIFIER}-s]:=$FTAG_ACTIONS[ACTION_TWF_SWITCH]}

# Adding everything to main array
local -a tmp=(${(@)${(@v)FTAG_KEYBINDINGS}//(#m)*/${(k)FTAG_KEYBINDINGS[(r)${(b)MATCH}]} \= ${(@k)FTAG_ACTIONS[(r)${(b)MATCH}]}})
local k v j
for k v (${(@kv)FTAG_KEYBINDINGS}) { FTAG[key__${k}]=$v; }
for k v (${(@kv)FTAG_ACTIONS})     { FTAG[action__${k#ACTION_}]=$v; }
for j (${tmp[@]})                  { FTAG[map__${${(s:=:)j}[1]}]=${${(s:=:)j}[2]} }

# Actions used for fzf
typeset -a __FTAG_ACTIONS
__FTAG_ACTIONS=( ${(@)${(k)FTAG_KEYBINDINGS//(#m)*/\-\-bind=$MATCH:${FTAG_KEYBINDINGS[${(z)MATCH}]}}} )
# ]]] == END: Config

# SECTION: == Create Filter == [[[
# File path content marks how to execute next command in the main loop
local current_filter
current_filter=${XDG_RUNTIME_DIR:-${XDG_CACHE_DIR:-${TMP-/tmp}}}/tag-filter
if ! command touch $current_filter; then
  +Ftag::msg -p "{err}{brgreen}${prog}{res}: Can't create a marker file needed for internal state management.{res}"
fi
# ]]] == END: Create Filter

# SECTION: == Actions == [[[
# Keys to show within the TUI
if [[ "${_FZFTAG_SHOW}" = "keys" ]]; then
  Ftag::default_header -s "ftag keybindings" -c 5
  local header
  local -a keys
  # Not sure how to put this in array as one element other than this, it reads as 3
  header=$(+Ftag::msg -p "{brred}KEY"$'\t\t'"{brmagen}ACTION"$'\t\t\t\t'"{byell}FZFTAG_ACTION{res}")
  line=$(+Ftag::msg -p "{brred}==="$'\t\t'"{brmagen}======"$'\t\t\t\t'"{bryell}============={res}")
  keys=( $header $line )
  keys+=( ${(@)${(f)"$(Ftag::show_keys)"}/$'\t'/} )
  print -rl -- $keys
  exit 0
fi

if [[ -n "$FZFTAG_ACTION" ]]; then
  # trap 'Ftag::tag ${(z)${(@f)"$(<$current_filter)"}}' EXIT
  clear
  # Get the filename e.g., %HOME/test
  local nl=$'\n' f
  typeset -ga pathf
  pathf=( ${(@)${${(f)"$(<$@)"}/(#m)*/${${(ws: :)MATCH}[1]}}} )
  # Call once for options that don't allow multiple
  Ftag::map-back "${pathf}"
  case "$FZFTAG_ACTION" in
    (test)
      # Testing for development
      local fname fdir tag file nl=$'\n'
      Ftag::parse_format "test"
      vared -cp "TEST: ${nl}$(Ftag::vared-format ${pathf[@]})${nl}${nl} Tags  " tag
      # for file in "${(f)reply[@]}"; do
      # done
      ;;
    (set)
      local fname fdir tag file
      Ftag::parse_format "set tags"
      vared -cp "${FTAG[byell]}[]${FTAG[res]} ${FTAG[und]}Set tags for${FTAG[res]}:${nl}$(Ftag::vared-format ${pathf[@]})${nl}${nl} " tag
      for file in "${pathf[@]}"; do
        Ftag::map-back "$file"
        # Wutag only works if variables are set first
        fname="${reply:t}" fdir="${reply:h}"
        # Wutag is called in addition unless -ww
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -s "$fdir" "$fname" "$tag"
        } elif (( FZFTAG_WTAG == 1 )) {
          command tag --set "${tag}" "$file"
          Ftag::wutag -s "$fdir" "$fname" "$tag"
        } else {
          command tag --set "${tag}" "$reply"
        }
      done
      ;;
    (add)
      local fname fdir tag file
      Ftag::parse_format "add tags"
      vared -cp "${FTAG[bgreen]}[+]${FTAG[res]} ${FTAG[und]}Add tags for${FTAG[res]}:${nl}$(Ftag::vared-format ${pathf[@]})${nl}${nl} " tag
      for file in "${pathf[@]}"; do
        Ftag::map-back "$file"
        fname="${reply:t}" fdir="${reply:h}"
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -a "$fdir" "$fname" "$tag"
        } elif (( FZFTAG_WTAG == 1 )) {
          command tag --add "${tag}" "$reply"
          Ftag::wutag -a "$fdir" "$fname" "$tag"
        } else {
          command tag --add "${tag}" "$reply"
        }
      done
      ;;
    (remove)
      local fname fdir tag file
      Ftag::parse_format "remove tags"
      vared -cp "${FTAG[bred]}[]${FTAG[res]} ${FTAG[und]}Remove tags for${FTAG[res]}:${nl}$(Ftag::vared-format ${pathf[@]})${nl}${nl} " tag
      for file in "${pathf[@]}"; do
        Ftag::map-back "$file"
        fname="${reply:t}" fdir="${reply:h}"
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -r "$fdir" "$fname"
        } elif (( FZFTAG_WTAG == 1 )) {
          command tag --remove "${tag}" "$reply"
          Ftag::wutag -r "$fdir" "$fname"
        } else {
          command tag --remove "${tag}" "$reply"
        }
      done
      ;;
    (ripgrep)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with ripgrep"; return 1
      } || {
      local yesno keyw
      Ftag::parse_format "ripgrep search"
      vared -cp "Local search [Y/n]: " yesno
      vared -cp " Ripgrep keyword: " keyw
      [[ "$yesno" == (#i)n ]] && {
        () {
            setopt localoptions noautopushd
            builtin cd -q "${reply:h}"
            Ftag::RG "$keyw"
          }
        } || Ftag::RG "$keyw"
      }
      ;;
    (usage)
      tag --usage | ${${(z)${(M)${FTAG_PAGER}:#bat*}:+${FTAG_PAGER} -l bash}:-less}
      ;;
    (edit)
      # TODO: maybe change to open
      ${EDITOR:-vim} "$reply"
      ;;
    (file-manager)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with file-manager"; return 1
      } || $FTAG_FILEMANAGER "${reply:h}"
      ;;
    (git)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with git"; return 1
      } || {
        Ftag::is_git "${reply:h}" >/dev/null && Ftag::gitui "${reply:h}"
      }
      ;;
    (forgit)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with forgit"; return 1
      } || Ftag::forgit "${reply:h}"
      ;;
    (dotbare)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with dotbare"; return 1
      } || Ftag::dotbare "${reply:h}"
      ;;
    (gpg-edit)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with gpg-edit"; return 1
      } || Ftag::gpg -e "$reply"
      ;;
    (gpg)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with gpg"; return 1
      } || Ftag::gpg "$reply"
      ;;
    (dua)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with dua"; return 1
      } || Ftag::dua "${reply:h}"
      ;;
    (twf-edit)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with twf-edit"; return 1
      } || { Ftag::dep "twf" && Ftag::twf -e "${reply:A:h}" }
      ;;
    (glow)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with glow"; return 1
      } || Ftag::glow "${reply:A:h}"
      ;;
    (bat-view)
      () {
        builtin emulate -LR zsh -o extendedglob -o noshortloops -o warncreateglobal
        local -a batv
        local f; for f ($pathf) { Ftag::map-back "$f" && batv+=( "$reply" ) }
        ${${(z)${(M)${FTAG_PAGER}:#bat*}:+bat --paging=always -f --style=header,snip}:-less} "${batv[@]}"
      }
      ;;
    (open-finder)
      () {
        builtin emulate -LR zsh -o noshortloops -o warncreateglobal
        local f; for f ($pathf) { Ftag::map-back "$f" && open "${reply:A:h}" } && exit
      }
      ;;
    (open)
      # External programs
      () {
        builtin emulate -LR zsh -o noshortloops -o warncreateglobal
        local f; for f ($pathf) {
          Ftag::map-back "$f"
          case "$(file --mime-type -b ${reply:A})" in
            (image/*) (
              Ftag::dep "feh" && ${commands[setsid]:-nohup} feh -. -x -B black -g 900x600-15+60 "${reply:A}"
              ) || (
              Ftag::dep "sxiv" && ${commands[setsid]:-nohup} sxiv -ai "${reply:A}"
              ) ;;
            (video/*)
              ${commands[setsid]:-nohup} mpv --ontop --no-border --force-window \
                    --autofit=500x280 --geometry=-15-53 "${reply:A}" ;;
            (audio/*) mpv "${reply:A}" ;;
            (application/pdf|application/vnd*|application/epub*) ${commands[setsid]:-nohup} zathura "${reply:A}" ;;
            (image/x-xcf) ${commands[setsid]:-nohup} gimp "${reply:A}" ;;
            (*) ${EDITOR:-vim} "${reply:A}" ;;
          esac
        } && exit
      }
    ;;
    (external-view)
      # TUI programs - no dependency checks
      (( $#pathf > 1 )) && { OS::notify "Only one selection is permitted with preview"; return 1 }
      {
        case "${reply:e}" in
          (text/html) w3m "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (zip) atool --list -- "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (tgz|tar.gz) tar tzf "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (tar.bz2|tbz2) tar tjf "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (tar.txz|txz) xz --list "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (tar) tar tf "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (jar|war|ear|oxt) unzip -l "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (rar) unrar l "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (7z) 7z l "${reply:A}" | ${(z)FTAG_PAGER} ;;
          ([1-8]) man "${reply:A}" | col -b | ${(z)FTAG_PAGER} ;;
          (o) nm "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (torrent) transmission-show "${reply:A}" | "${(z)FTAG_PAGER}" ;;
          (iso) iso-info --no-header -l "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (odt|ods|odp|sxw) odt2txt "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (doc) catdoc "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (docx) docx2txt "${reply:A}" | ${(z)FTAG_PAGER} ;;
          # (csv) bat "${reply:A}" | sed s/,/\\n/g ;;
          # (csv) bat --paging=always -f -l csv "${reply:A}" ;;
          (csv) ${(z)${${(M)FTAG_PAGER:#bat*}:+${FTAG_PAGER} -l csv}} "${reply:A}" ;;
          (json) jq --color-output . "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (asc) cat "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (sha1|sha256|sha512|md5) rhash -c "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (ipynb) jupview -t KimbieDark "${reply:A}" | ${(z)FTAG_PAGER} ;;
          (pdf) pdftotext -l 10 -nopgbrk -q "${reply:A}" - | ${(z)FTAG_PAGER} ;;
          (jpg|jpeg|png) viu "${reply:A}" | ${(z)FTAG_PAGER} ;;
          # (*) mediainfo "${reply:A}" ;;
        esac
      } always {
          Ftag::dep "mediainfo" && mediainfo "${reply:A}" | ${(z)FTAG_PAGER}
      }
      ;;
    (delete)
      () {
        builtin emulate -LR zsh
        builtin setopt noshortloops extendedglob ${${${+reply}:#0}:+warncreateglobal}
        local yesno; local -a array; integer ret=1
        local f; for f ($pathf) { Ftag::map-back "$f" && array+=( "$reply" ) }
        (( $#array > 1)) && {
          vared -cp " Delete files ${array[@]:t3}? [Y/n] " yesno
        } || vared -cp " Delete file ${array:t3}? [Y/n] " yesno
        [[ "$yesno" == (#i)y ]] && {
          for f ($array) {
            case 1 in
              (${+commands[trash-put]}) trash-put "${f}" && OS::notify "put: ${f:t} deleted"; ret=$? ;;
              (${+commands[rip]}) rip "${f}" && OS::notify "rip: ${f:t} deleted"; ret=$? ;;
              (${+commands[dump]}) dump "${f}" >/dev/null && OS::notify "dump: ${f:t} deleted"; ret=$? ;;
              (${+commands[gomi]}) gomi "${f}" && OS::notify "gomi: ${f:t} deleted"; ret=$? ;;
              (${+commands[osascript]})
                    osascript -e 'tell application "Finder" to delete every item of {''(POSIX file "'${^f:A}'")''}' \
                      >/dev/null
                      ret=$? ;;
              (*) zmodload -F zsh/files b:zf_rm && zf_rm "$f" && OS::notify "${f:t} deleted"; ret=$? ;;
            esac
          }
          return $ret
        }
      }
      ;;
    (copy)
      () {
        builtin emulate -LR zsh
        builtin setopt noshortloops extendedglob ${${${+reply}:#0}:+warncreateglobal}
        local -a array
        local f; for f ($pathf) { Ftag::map-back "$f" && array+=( "$reply" ) }
        ${(z)FTAG_COPY} <<< $array && return 0
      }
      ;;
    (dragon-source)
      () {
        builtin emulate -LR zsh
        builtin setopt noshortloops extendedglob ${${${+reply}:#0}:+warncreateglobal}
        local -a array; integer ret=1
        local f; for f ($pathf) { Ftag::map-back "$f" && array+=( "$reply" ) }
        Ftag::dep "dragon" && {
          dragon -x -p "${array[@]}" && ret=0
          exit $ret
        }
        return $ret
      }
      ;;
  esac
  clear
  print -Pr -- "${FTAG[red]}${(l:COLUMNS::=:):-}${FTAG[res]}"
  print "End of 'ftag "$FZFTAG_ACTION"' output. Press any key to continue"
  print -Pr -- "${FTAG[red]}${(l:COLUMNS::=:):-}${FTAG[res]}"
  read -qs
  exit $?
fi
# ]]] == END: Actions

# SECTION: == State Change == [[[
local -a FZFTAG_CMD
local dir_switch
if [[ -n "$FZFTAG_STATE_CHANGE" ]]; then
  case "$FZFTAG_STATE_CHANGE" in
    local)
      FZFTAG_CMD=( "-l" )
      ;;
    global)
      FZFTAG_CMD=( "-f" "*" )
      ;;
    path)
      dir_switch=$(Ftag::path::find)
      [[ -d ${~dir_switch} ]] || { OS::notify "Not a directory"; return 1 }
      FZFTAG_CMD=( "-f" "*" ${~dir_switch} )
      # osa "$FZFTAG_CMD"
      ;;
    zoxide)
      dir_switch=$(Ftag::zoxide)
      [[ -d ${~dir_switch} ]] || { OS::notify "Not a directory"; return 1 }
      FZFTAG_CMD=( "-f" "*" ${~dir_switch} )
      ;;
    autojump)
      dir_switch=$(Ftag::autojump)
      [[ -d ${~dir_switch} ]] || { OS::notify "Not a directory"; return 1 }
      FZFTAG_CMD=( "-f" "*" ${~dir_switch} )
      ;;
  esac

  print -Rn "$FZFTAG_CMD" > $current_filter
  exit $?
fi
# ]]] == END: State Change

# SECTION: == Reload == [[[
# FIX: unused
local filter output
if [[ -n "$_FZFTAG_RELOAD" ]] {
  filter=( ${(@f)"$(<$current_filter)"} )
  # output="$(Ftag::tag "${(z)filter}")"
  Ftag::tag "${(z)filter}"
  OS::notify "reload"
  exit $?
}
# ]]] == END: Reload

# SECTION: == Remove Filter == [[[
# No state change, no action, and no reload, remove filter
[[ $+FZFTAG_STATE_CHANGE != 1 && $+FZFTAG_ACTION != 1 && "${_FZFTAG_INTERNAL}" != "reload"
]] &&
  rm -f "$current_filter"
# ]]] == END: Remove Filter

# SECTION: == Preview == [[[
(( ${+FZFTAG_PREV} )) && {
  local -a pathf
  pathf=( ${(@)${${(f)"$(<$@)"}/(#m)*/${${(ws: :)MATCH}[1]}}} )
  Ftag::map-back "$pathf"
  Ftag::declare "FTAG_FILE_PREV=bat --style=numbers --color=always"
  Ftag::declare "FTAG_DIR_PREV=exa -TL 3"
  [[ -f "$reply" ]] && ${(z)FTAG_FILE_PREV} "$reply"
  [[ -d "$reply" ]] && ${(z)FTAG_DIR_PREV} "$reply" | ${commands[bat]:-less}
  exit $?
}
# ]]] == END: Prievew

# SECTION: == Main Loop == [[[
# Used for fzf preview
# Variables have to be exported to be picked up on the next iteration of the loop
typeset -giH {FZFTAG_WTAG,FZFTAG_BOXES,FZFTAG_LOLCAT,FZFTAG_TOILET,VERBOSE,NO_COLOR,WRAPPER}=0
typeset -gH  FZFTAG_STATE_CHANGE FZFTAG_FONT
while (( $? != 130 )) {
  VERBOSE=$#verbose
  Ftag::opts "n nocolor" && NO_COLOR=1

  if Ftag::opts "w wutag"; then
    if Ftag::dep "wutag"; then
      if (( $#wtag > 1 )) {
        export FZFTAG_WTAG=2
      } else {
        export FZFTAG_WTAG=1
      }
    else
      +Ftag::msg -p "{warn}{green}wutag{res} is not in PATH" \
        $'\n'"Install {green}wutag{res} or don't use {yell}-w{res},{yell}--wutag{res}"
    fi
  fi

  (( ${+cfont} ))       && export FZFTAG_FONT="${opts[-f]}"
  Ftag::opts "b boxes"  && export FZFTAG_BOXES=1
  Ftag::opts "c lolcat" && export FZFTAG_LOLCAT=1
  Ftag::opts "t toilet" && export FZFTAG_TOILET=1

  local -a tag_arguments
  # If writeable, that means theres a state change
  if [[ -w "$current_filter" ]]; then
    tag_arguments=( ${(@f)"$(<$current_filter)"} )
    LANG=C command sleep 0.002
  else
  # First time ran
    if Ftag::opts "l local"; then
      tag_arguments=( "-l" )
    elif Ftag::opts "p path"; then
      tag_arguments=( "-f" "*" "$FZFTAG_PATH" )
    elif Ftag::opts "z zoxide"; then
      Ftag::dep -e "zoxide"
      dir_switch=$(Ftag::zoxide)
      tag_arguments=( "-f" "*" "$dir_switch" )
    elif Ftag::opts "j jump"; then
      Ftag::dep -e "autojump"
      dir_switch=$(Ftag::autojump)
      tag_arguments=( "-f" "*" "$dir_switch" )
    else
      # Don't quote *
      tag_arguments=( "-f" "${@:-*}" )
    fi
    print -Rn "${tag_arguments[@]}" >! $current_filter
  fi

  # Set prompt
  local -a FZFTAG_OPTS
  if Ftag::opts "l local" || [[ "$FZFTAG_STATE_CHANGE" = "local" ]]; then
    FZFTAG_OPTS=( "--prompt ' Local Tag> '" )
  elif Ftag::opts "p path" || [[ "$FZFTAG_STATE_CHANGE" = "path" ]]; then
    FZFTAG_OPTS=( "--prompt ' Path> '" )
  elif Ftag::opts "z zoxide" || [[ "$FZFTAG_STATE_CHANGE" = "zoxide" ]]; then
    FZFTAG_OPTS=( "--prompt ' Zoxide Tag> '" )
  elif Ftag::opts "j jump" || [[ "$FZFTAG_STATE_CHANGE" = "autojump" ]]; then
    FZFTAG_OPTS=( "--prompt ' Jump Tag> '" )
  else
    # FZFTAG_OPTS=( "--prompt 'Tag> '" "--delimiter /" "--with-nth 4.." )
    FZFTAG_OPTS=( "--prompt 'Tag> '" )
  fi

  [[ "${_FZFTAG_INTERNAL}" == "reload" ]] && {
    Ftag::tag "${(z)${(@f)"$(<$current_filter)"}}"
    exit $?
  }

  # local tfd
  # sysopen -r -o cloexec -u tfd <(() {
  #   eval 'Ftag::tag "${(z)tag_arguments}"';
  # } && terminal-notifier -title "x" -message "x")

  Ftag::opts "N nofzf" && {
    Ftag::tag "${(z)tag_arguments}"
    return
  }

  Ftag::opts "W wrapper" && {
    export WRAPPER=1
    # Not sure if this speeds up at all
    Ftag::parallel 'Ftag::tag "${wrapper#-W}"'
    # zmodload -Fa zsh/zpty b:zpty && {
    #   zpty "ftag" 'Ftag::tag "${wrapper#-W}"'
    #   zpty -r "ftag"
    #   zpty -d "ftag"
    # } || Ftag::tag "${wrapper#-W}"
    return ret
  }

  Ftag::tag "${(z)tag_arguments}" \
      | fzf \
      ${${(z)${(j. .)FZFTAG_OPTS}}//\'} \
      --ansi \
      --query "$FZFTAG_QUERY" \
      --multi \
      --info=inline \
      --pointer '➤' \
      --no-height \
      --preview-window=':hidden,right:60%' \
      --preview "env FZFTAG_PREV=1 $0 {+f}" \
      "${__FTAG_ACTIONS[@]}"
}
# ]]] == END: Main Loop

# zle && zle reset-prompt || clear

# vim: ft=zsh:et:sw=0:ts=2:sts=2:fdm=marker:fmr=[[[,]]]:
