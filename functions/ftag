#!/usr/bin/env zsh

############################################################################
#    Author: Lucas Burns                                                   #
#     Email: burnsac@me.com                                                #
#   Created: 2021-06-14 20:45                                              #
#   Description: Fzf TUI for jdberry's tagging on macOS                    #
############################################################################

# == Setup == [[[
emulate -LR zsh
builtin setopt extendedglob typesetsilent noksharrays

0="${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}"
0="${${(M)0:#/*}:-$PWD/$0}"
local prog prog_dir
prog="${0:A:t}"   prog_dir="${0:A:h}"

# TODO: confirm support for file paths with spaces

# TODO: find a way to display hidden tagged files
# TODO: fix alignment if not part of mapping hash

# TODO: add option for tag separator symbol
# ]]] == END: Setup

# SECTION: == Functions: Helper == [[[
# FUNCTION: +Ftag::msg [[[
# Map colors to FTAG array and recognize errors and warnings
function +Ftag::msg() {
  builtin emulate -LR zsh
  setopt extendedglob noksharrays noshortloops warncreateglobal
  local opt msg
  typeset -gi ret
  local -a match mbegin mend
  [[ $1 = -* ]] && { opt=$1; shift; }
  msg=${${(j: :)${@}}//\%/%%}
  msg=${msg/(#b)\{(warn|err)\}/\{bred\}${${${(M)match:#warn}:+\[Warning\]}:-\[Error\]}:\{res\} }
  msg=${${msg//(#b)([\{]([^\}]##)[\}])/${FTAG[${${match[1]}//([\{\}])/}]}}}

  if [[ $opt = -x ]] {
    REPLY=${msg}${FTAG[res]}
    return
  } else {
    [[ -n ${(M)msg:#(#i)*(warn*|err*)*} ]] && {
      builtin print -u2 ${opt:#--} -- $msg
    } || builtin print -Pr ${opt:#--} -- $msg
  }

  # FIX: allow %F
  # msg=${${msg//(#b)(([\\]|(%F))([\{]([^\}]##)[\}])|([\{]([^\}]##)[\}])([^\%\{\\]#))/${FTAG[${${match[1]}//([\{\}])/}]}}}
  # msg=${${msg//(#b)((|(%F))[\{]([^\}]##)[\}])/${(M)match[1]:#%F*}:+$match[1]}:-${FTAG[${${match[1]}//([\{\}])/}]}}
}
# ]]]

# FUNCTION: Ftag::dep [[[
# $1 - dependency to check
# If '-e', will throw error
function Ftag::dep() {
  [[ $1 = -e ]] && { integer err=1; shift; }
  if (( err )); then
    { ( (( ${+commands[$1]} )) || whence -vp $1 >/dev/null ) && return 0 } || {
      +Ftag::msg "{err}{green}${1}{res} is not in {yell}\$PATH{res}"; exit 1;
    }
  else
    ( (( ${+commands[$1]} )) || whence -vp $1 ) && return 0
  fi
}
# ]]]

# FUNCTION: Ftag::opts [[[
# Check if option was passed
# $@ - string of options; e.g., "h help"
function Ftag::opts() {
  ( (( ${+opts[-${${(@s. .)@}[1]}]} || ${+opts[--${${(@s. .)@}[2]}]} )) ) && return 0
}
# ]]]

# FUNCTION: Ftag::is_git [[[
function Ftag::is_git() { command git -C "${(z)@}" rev-parse --is-inside-work-tree; }
# ]]]

# FUNCTION: Ftag::declare [[[
# Declare global variable for config
function Ftag::declare() {
  integer prnt=0
  [[ $1 = -X ]] && { prnt=1; shift; }
  [[ $1 = -* ]] && { local opt=$1; shift; }
  local -i set; set=$+parameters[${${(s:=:)@}[1]}]
  (( set )) || {
    [[ $opt = (#i)-a ]] && {
      eval "typeset -Hg${opt#-} ${${(s:=:)@}[1]}=${(fz)${(s:=:)@}[2]}"
    } || typeset -gH "${${(s:=:)@}[1]}=${${(s:=:)@}[2,-1]}"
  (( prnt )) && print 0
  return 0
  }
  (( prnt )) && print 1
  return 1
}
# ]]]

# FUNCTION: Ftag::color-tag [[[
# $1 - Tag to color
function Ftag::color-tag() {
  builtin emulate -LR zsh
  setopt extendedglob typesetsilent rcquotes ${${${+REPLY}:#0}:+warncreateglobal}
  REPLY="${1:+${__c1}${${1//(#m)(\|)/${__c2}${MATCH}${FTAG[res]}${__c1}}}${FTAG[res]}}"
  # REPLY="${1:+${FTAG[bmagen]}${${1//(#m)(\|)/${FTAG[blue]}${MATCH}${FTAG[res]}${FTAG[bmagen]}}}${FTAG[res]}}"
  return 0
}
# ]]]

# FUNCTION: Ftag::map-short [[[
# $1 - File path to color and map to map hash
function Ftag::map-short() {
  builtin emulate -LR zsh
  setopt extendedglob typesetsilent noshortloops rcquotes
  typeset -gH SHORT
  local -a match mbegin mend
  # Color: head
  SHORT=${${1/(#b)(#s)(${(~j:|:)${(O@k)FTAG_DIR_MAP}}|)/${FTAG_DIR_MAP[$match[1]]:+${__c3}${FTAG_DIR_MAP[$match[1]]}${FTAG[res]}}}}

  # Color: head and tail
  # if [[ ${SHORT:h} != (${~SHORT:t}|\.) ]]; then
  #   reply=( "${SHORT:h}" "${${SHORT:t}:+${FTAG[blue]}${SHORT:t}${FTAG[res]}}")
  # else
  #   reply=( "$SHORT" )
  # fi
  return 0
}
# ]]]

# FUNCTION: Ftag::map-back [[[
# $1 - File path to map back to original path
function Ftag::map-back() {
  builtin emulate -LR zsh
  setopt extendedglob typesetsilent rcquotes ${${${+reply}:#0}:+warncreateglobal}
  # typeset -ga reply; reply=()
  local -a match mend mbegin
  local __f

  for __f in "${@}"; do
    if [[ "$__f" = (#s)%* ]] {
      reply=( ${${__f/(#b)(#s)(${(~j:|:)${(@v)FTAG_DIR_MAP}}|)/${(~k)FTAG_DIR_MAP[(r)$match[1]]}}} )
    } else {
      reply=( "$__f" )
    }
  done
}
# ]]]

# FUNCTION: Ftag::ini::read [[[
# Taken from zdharma/fast-syntax-highlighting
# Parse configuration file
function Ftag::ini::read() {
  emulate -LR zsh
  setopt extendedglob rcquotes warncreateglobal
  local __ini_file="$1" __out_hash="${2:-INI}"
  local IFS='' __line __cur_section="void" __access_string
  local -a match mbegin mend

  [[ ! -r "$__ini_file" ]] && {
    +Ftag::msg "{err}$__ini_file is unreadable"
    return 1
  }

  while read -r -t 1 __line; do
    if [[ "$__line" = [[:blank:]]#\;* ]]; then
      continue
    elif [[ "$__line" = (#b)[[:blank:]]#\[([^\]]##)\][[:blank:]]# ]]; then
      __cur_section="${match[1]}"
    elif [[ "$__line" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then
      match[2]="${match[2]%"${match[2]##*[! $'\t']}"}"
      __access_string="${__out_hash}[<$__cur_section>_${match[1]}]"
      : "${(P)__access_string::=${match[2]}}"
    fi
  done < "$__ini_file"

  return 0
}
# ]]]

# FUNCTION: Ftag::tag [[[
# Tag wrapper to color the output
# TODO: speed up
function Ftag::tag() {
  emulate -LR zsh
  setopt extendedglob warncreateglobal typesetsilent noksharrays \
            noshortloops nomonitor nonotify

  local -a targs tags fargs files tmp
  fargs=( "${(Q@)${(@z)@}}" )

  # Have a single check for wrapper instead of case statement for speed
  (( WRAPPER )) && {
    local __action=${fargs[1]#-}
    case "$fargs" in
      (-s*|--set*)
        [[ $#fargs -eq 3 && $fargs[1] = -(s|-set) && $fargs = -(s*|-set*)
        ]] && {
          command tag --set "$fargs[2]" "$fargs[3]" 2>/dev/null && {
            +Ftag::msg "{brblue}Tag:{res} $fargs[2]{tb}{brblue}Set:{res} $fargs[3]"
          } || +Ftag::msg '{err}tag cannot be set'
        }
        ;;
      (-r*|--remove*)
        [[ $#fargs -eq 3 && $fargs[1] = -(r|-remove) && $fargs = -(r*|-remove*)
        ]] && {
          command tag --remove "$fargs[2]" "$fargs[3]" 2>/dev/null && {
            +Ftag::msg "{brblue}Tag:{res} $fargs[2]{tb}{brblue}Removed:{res} $fargs[3]"
          } || +Ftag::msg '{err}tag cannot be removed'
        }
        ;;
      (-a*|--add*)
        [[ $#fargs -eq 3 && $fargs[1] = -(a|-add) && $fargs = -(a*|-add*)
        ]] && {
          command tag --add "$fargs[2]" "$fargs[3]" 2>/dev/null && {
            +Ftag::msg "{brblue}Tag:{res} $fargs[2]{tb}{brblue}Added:{res} $fargs[3]"
          } || +Ftag::msg '{err}tag cannot be added'
        }
        ;;
      (-l|--list)
        [[ $#fargs -eq 1 && $fargs[1] = -(l|-list) ]] && {
          tmp=( ${${${(@)${(@f)"$(tag -Al)"}/(#m)([[:space:]]|(#e))/---${MATCH}}//[[:space:]]/}//(#m)---(#e)/---Â } )
          tags=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[2]}}} )
          files=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[1]}}} )
        }
        ;;
      (-u*|--usage*)
        () {
          emulate -LR zsh
          setopt extendedglob warncreateglobal noksharrays noshortloops nokshglob
          local -a tcnts ttags
          if [[ $#fargs -eq 1 && $fargs[1] = -(u|-usage) ]] {
            # tag -u
            tcnts=( ${${(@f)"$(tag --usage)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[1]}} )
            ttags=( ${${(@f)"$(tag --usage)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}} )
          } elif [[ $#fargs -eq 2 && $fargs[1] = -(u|-usage) && $~fargs[2] = (#s)(\~|\/|.##)*/#* ]] {
            # tag -u ~/dir
            tcnts=( ${${(@f)"$(tag --usage ${(z)~fargs[2]})"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[1]}} )
            ttags=( ${${(@f)"$(tag --usage ${(z)~fargs[2]})"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}} )
          } elif [[ $#fargs -eq 3 && $fargs[1] = -(u|-usage) && $~fargs[3] = (#s)(\~|\/|.##)*/#* ]] {
            # tag -u <tag> ~/dir
            [[ $fargs[2] = [[:ascii:]]## ]] && {
              tcnts=( ${${(@f)"$(tag --usage ${(z)~fargs[3]})"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[1]}} )
              ttags=( ${${(@f)"$(tag --usage ${(z)~fargs[3]})"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}} )
              local exists=${(M)ttags:#${fargs[2]}}
              [[ -n $exists ]] && {
                # Normal tag does not do this; selecting one tag in a directory
                tcnts=${(@)${tcnts[${ttags[(rI)$exists]}]}}
                Ftag::color-tag "$exists"
                +Ftag::msg "{brgreen}$tcnts{res} $REPLY"
                return 0
              } || { +Ftag::msg "{err}{cyan}$fargs[2]{res} is not an existing tag"; return 1; }
            }
          } else {
              +Ftag::msg "{err}{cyan}$fargs{res} is an incorrect usage of {yell}--usage{res}"; return 1;
          }
          # SEE: if can fallthrough
          local -a packs unpacked;    integer i longest=0 adjust;     local t
          for (( i=1; i<=$#ttags; i++ )) { packs+=( "${(q)${tcnts[$i]}} ${(q)${ttags[$i]}}" ); }
          for t ($packs) { unpacked=( "${(Q@)${(z@)t}}" ); (( $#unpacked[1] > $longest )) && longest=$#unpacked[1]; }
          adjust=$(( ${#FTAG[brgreen]} + ${#FTAG[res]} ))
          for t ($packs) {
            unpacked=( "${(Q@)${(z@)t}}" )
            Ftag::color-tag "$unpacked[2]"
            unpacked[1]=${__bc3}${unpacked[1]}${FTAG[res]}
            builtin print -n "${(r:longest+adjust+1:: :)unpacked[1]} $REPLY"
            builtin print
          }
        }
        ;;
      (-h|--help)
        # tag -h
        +Ftag::msg "{bgreen}{und}External tag help:{res}" \
          "{nl}${${${(@)$(command tag --help)}//(#m)(${(~j:|:)__FTAG_EXTERNAL_OPTS})/${FTAG[yell]}${MATCH}${FTAG[res]}}//(#m)(-##[[:alnum:]]##)/${FTAG[green]}${MATCH}${FTAG[res]}}"
        ;;
      (*-[[:alpha:]]#g[[:alpha:]]#*|*--garrulous*)
        () {
          emulate -LR zsh
          setopt extendedglob warncreateglobal noksharrays noshortloops nokshglob
          integer -g GARRULOUS=1
          local -a fst_fargs=( ${(s::)${fargs[1]#-}} )
          if [[ $#fargs -eq 1 && ( $#fst_fargs -eq 1 && $fst_fargs[1] = (g|l) ||
              ( $#fst_fargs -eq 2 && $fst_fargs[1] = (g|l) && $fst_fargs[2] = (g|l) ) )
          ]] {
            # Only passing -g implies -l
            # tag -g | tag -
            tmp=( ${${${(@)${(@f)"$(tag -Al)"}/(#m)([[:space:]]|(#e))/---${MATCH}}//[[:space:]]/}//(#m)---(#e)/---Â } )
            tags=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[2]}}} )
            files=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[1]}}} )
          } elif [[ $#fargs -eq 2 && ( ( $#fst_fargs -eq 2 && $fargs = *f* ) ||
                    $#fst_fargs -eq 3 && $fargs = *f* && $fargs = *t* ) && $fargs[-1] = (\*|[[:alnum:]]##)
          ]] {
            # Same behavior for tag -gf '*' and tag -gtf '*'
            fargs[1]=${fargs[1]/t/}
            targs=( "-ANtf" "${fargs[-1]}" )
          } elif [[ $#fargs -eq 3 && ( ( $#fst_fargs -eq 2 && $fargs = *f* ) ||
                    $#fst_fargs -eq 3 && $fargs = *f* && $fargs = *t* ) && $fargs[-1] = (#s)(\~|\/|.##)*/#*
          ]] {
            # Same behavior for tag -gf '<tag>' <dir> and tag -gtf '<tag>' <dir>
            fargs[1]=${fargs[1]/t/}
            targs=( "-ANtf" "${fargs[-2]}" "${fargs[-1]}" )
          } elif [[ $#fargs -eq 2 && $#fst_fargs -eq 2 && $fargs = *m* ]] {
            targs=( "-ANtf" "${fargs[-1]}" "." )
          } else {
            +Ftag::msg "{err}only the following tags are supported with garrulous mode:" \
                "{nl}-{yell}g{res}, -{yell}gl{res}" \
                "{nl}-{yell}gf{res} '{green}<tag>{res}' {green}<dir>{res}, -{yell}gtf {green}<tag> <dir>{res}{tb}(same output)" \
                "{nl}-{yell}gf{res} '{green}<tag>{res}', -{yell}gtf {green}<tag>{res}{tb}(same output, global search)" \
                "{nl}-{yell}gm{res} '{green}<tag>{res}'{tb}(local search)" \
            # FIX: two exits required to actually exit
            exit; exit
          }
        # Can't use (( )) if tags in unset. Tried [[ ! -v tags ]]
        if [[ $#tags -eq 0 ]] {
            tags=( ${(@f)"$(tag ${(z)targs})"} )
            files=( ${(@f)"$(tag ${(z)fargs})"} )
          }
        }
        ;;
      (*-[[:alpha:]]#m[[:alpha:]]#*|*--match*)
        () {
          emulate -LR zsh
          setopt extendedglob warncreateglobal noksharrays noshortloops nokshglob
          local -a fst_fargs=( ${(s::)${fargs[1]#-}} )
          if [[ $#fargs -eq 1 ]] {
            +Ftag::msg "{err}you must supply a tag"
            exit 1
          } elif [[ $#fargs -eq 2 && $#fst_fargs -eq 1 && $fst_fargs = m ]] {
            local -a files=( ${(@f)"$(tag ${(z)fargs})"} )
            print -rl -- ${FTAG[green]}${files}${FTAG[res]}
            return 0
          } elif [[ $#fargs -eq 2 && $#fst_fargs -eq 2 && $fst_fargs[1] = t && $fst_fargs[2] = m ]] {
            # Normal tag requires -m and -f to be last flag since these flags require an argument
            # So, only check for -tm order here
            targs=( "-ANtm" "$fargs[-1]" )
            fargs=( "-ATm"  "$fargs[-1]" )
          } elif [[ $#fargs -eq 3 && $#fst_fargs = <2-3> && ( $fst_fargs[1] = t || $fst_fargs[2] = t ) &&
                ( $fst_fargs[2] = m || $fst_fargs[3] = m )
          ]] {
          # If tag -tm is given a dir along with a path, -e is required to enter directory
          # Here, (( -etm || -tem ) || -tm ) <tag> <dir> will be treated the same
          # Do not quote $~
            targs=( -ANetm $fargs[-2] $~fargs[-1] )
            fargs=( -Aem  $fargs[-2] $~fargs[-1] )
          }
        tags=( ${(@f)"$(tag ${(z)targs})"} )
        files=( ${(@f)"$(tag ${(z)fargs})"} )
        }
        ;;
      (*-[[:alpha:]]#f[[:alpha:]]#*|*--find*)
        # tag -tf '*'
        targs+=( "-ANtf" )
        if [[ $#fargs -eq 3 && $~fargs[-1] = (#s)(\~|\/|.##)*/#* ]]; then
          targs+=( "${fargs[-2]}" "${fargs[-1]}" )
        elif [[ $#fargs -eq 2 && $fargs[-1] = (\*|[[:alnum:]]##) ]]; then
          targs+=( "${fargs[-1]}" )
        else
          +Ftag::msg "{err}incorrect tag or path"
          return 1
        fi
        tags=( ${(@f)"$(tag ${(z)targs})"} )
        files=( ${(@f)"$(tag ${(z)fargs})"} )
        ;;
      (*)
        +Ftag::msg "{err}flag: ${fargs} is not supported"
        return 1
      ;;
    esac
  } || {
    # FZF specific
    if [[ $#fargs -eq 1 && $fargs[1] = -Al ]]; then
      tmp=( ${${${(@)${(@f)"$(tag -Al)"}/(#m)([[:space:]]|(#e))/---${MATCH}}//[[:space:]]/}//(#m)---(#e)/---Â } )
      tags=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[2]}}} )
      files=( ${(@)${tmp[@]//(#m)*/${${(As:---:)MATCH}[1]}}} )
    else
      (( ${+fargs[(r)-*f*]} )) && targs+=( "-ANtf" )
      if [[ $#fargs -eq 3 && $fargs[-1] = (#s)(\~|\/|.##)*/#* ]]; then
        targs+=( "${fargs[-2]}" "${fargs[-1]}" )
      elif [[ $#fargs -eq 2 && $fargs[-1] = (\*|[[:alnum:]]##) ]]; then
        targs+=( "${fargs[-1]}" )
      fi
      tags=( ${(@f)"$(tag ${(z)targs})"} )
      files=( ${(@f)"$(tag ${(z)fargs})"} )
    fi
  }

  integer i longest=0
  local t
  local -a packs unpacked
  for (( i=1; i<=$#tags; i++ )) {
    packs+=( "${(q)${files[$i]}} ${(q)${tags[$i]}//,/\|}" )
  }

 [[ -n $sort ]] && {
  if [[ "${sort#-s}" = (+|a|asc) ]]; then
    packs=( "${(on)packs[@]}" )
  elif [[ "${sort#-s}" = (++|d|desc) ]]; then
    packs=( "${(On)packs[@]}" )
  fi
  }

  for t ($packs) {
    unpacked=( "${(Q@)${(z@)t}}" )
    (( $#unpacked[1] > $longest )) && longest=$#unpacked[1]
  }

  for t in "${packs[@]}"; do
    unpacked=( "${(Q@)${(z@)t}}" )
    Ftag::color-tag "$unpacked[2]"
    Ftag::map-short "$unpacked[1]"
    # builtin print -n "${(r:longest+1:: :)${(j:/:)reply[@]}} $REPLY"
    (( NO_COLOR )) && {
      (( GARRULOUS )) && {
      builtin print -n "${unpacked[1]}"$'\n'"   $unpacked[2]"
      } || builtin print -n "${(r:longest+1:: :)unpacked[1]} $unpacked[2]"
    } || {
      (( GARRULOUS )) && {
      builtin print -n "${SHORT}"$'\n'"   $REPLY"
      } || builtin print -n "${(r:longest+1:: :)SHORT} $REPLY"
    }
    builtin print
  done

  case $VERBOSE in
    ( <1-> )
      +Ftag::msg "{brred}${(l:COLUMNS::=:):-}{res}" \
          "{bgreen}Command:{res} tag -${__action} ${fargs[2]:-} ${fargs[3]:-}" ;|
    ( <2-> )
      +Ftag::msg "{brblue}${(l:COLUMNS::=:):-}{res}" \
         "{bgreen}Length:{res} $#fargs" ;|
    ( <3-> )
      # Call this here as well as usage above so it's only called when needed
      () {
        builtin emulate -LR zsh -o extendedglob
        local -a gtags=( ${${(@f)"$(tag --usage)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}} )
        local -a ltags=( ${(@u)${(@s:,:)${(@f)"$(tag -Nl)"}}} )
        +Ftag::msg "{brblue}${(l:COLUMNS::=:):-}{res}" \
            "{bgreen}Global tags:{res}"
        # Using res does not color all tags
        print -c -- ${FTAG[bold]}${(n)gtags}
        +Ftag::msg "{res}{brblue}${(l:COLUMNS::=:):-}{res}" \
            "{bgreen}Local tags:{res}"
        print -c -- ${FTAG[bold]}${(n)ltags}
      }
      ;;
  esac
}
# ]]]

# FUNCTION: OS::notify [[[
# TODO: add option to permanently set notifications
function OS::notify() {
  { Ftag::dep "terminal-notifier" } && {
      terminal-notifier -title "${2:-Ftag}" -message "${1:-.}"
  } || osascript -e 'display notification "'"$*"'"'
}
# ]]]

# FUNCTION: Ftag::zstyle [[[
# Wrapper function for zstyle
function Ftag::zstyle() {
  builtin zstyle $1 :ftag: ${@:2}
}
# ]]]

# SECTION: == Unused == [[[
# FUNCTION: Ftag::parallel2 [[[
# An attempt to make reloading faster with many tags
# Still learning file descriptors
function Ftag::parallel2() {
  # [[ -o zle ]] && zle -I
  local TFD
  exec {TFD} < <(
      LANG=C sleep $(( 0.005 + ${${${(M)1#@sleep:}:+${1#@sleep:}}:-0} ))
      print -r -- ${1:#(@sleep:*)} "${@[2,-1]}"
  )
  zle -N Ftag::parallel
  zle -w -F "$TFD" Ftag::parallel
  # zle -F "$TFD" Ftag::parallel
}
# ]]]

# FUNCTION: Ftag::parallel [[[
function Ftag::parallel() {
  local -a fds=()
  local fd
  {
    local cmd
    for cmd in $@; do
      exec {fd}< <( eval "$cmd" )
      fds+=( $fd )
    done
  } always {
    for fd in $fds; do
      <&$fd
      exec {fd}<&-
    done
  }
}
# ]]]

# FUNCTION: @Ftag::sched [[[
function @Ftag::sched() {
  zmodload -Fa zsh/sched b:sched
  local AFD
  # sched +0 'Ftag::tag "${wrapper}"'
  sched +1 'Ftag::tag "${(z)tag_arguments}"'
  # sched +1 'echo "hi"'

  AFD=13371337
  exec {AFD}< <(LANG=C command sleep 0.002; builtin print run;)
  command true
  zle -F "$AFD" @Ftag::sched
  zle -F "$AFD" 2>/dev/null
}
# ]]]

# FUNCTION: Ftag::format_length [[[
# Could use to split lines based on $#COLUMN
function Ftag::format_length() {
  builtin emulate -LR zsh
  setopt extendedglob warncreateglobal typesetsilent noshortloops
  integer longest=0 longest_left=0 cur_left_len=0 count=1
  local f
  for f in "${(@)${nfiles:^ntags}}"; do
    [[ -z "$f" ]] && continue
    f="${(Q)f}"

    if (( count ++ %2 != 0 )); then
      [[ "${#f}" -gt "$longest_left" ]] && longest_left="${#f}"
      curr_left_len="${#f}"
    else
      curr_left_len+="${#f}"
      curr_left_len+=1
      [[ "$curr_left_len" -gt "$longest" ]] && longest="$curr_left_len"
    fi
  done

  local answer=""
  count=1
  for a in "${(@)${nfiles:^ntags}}"; do
    [[ -z "$f" ]] && continue
    f="${(Q)f}"

    if (( COLUMNS >= longest )); then
      if (( count ++ % 2 != 0 )); then
        answer+="${(r:longest_left+1:: :)f}"
      else
        answer+="$f"$'\n'
      fi
    else
      answer+="$f"$'\n'
    fi
  done
  REPLY="$answer"
  (( COLUMNS >= longest && count % 2 == 0 )) && REPLY="$REPLY"$'\n'
}
# ]]]
# ]]] == END: Unused
# ]]] == END: Helper

# SECTION: == Functions: Actions == [[[
# FUNCTION: Ftag::zoxide [[[
# Switch or query directory with zoxide
function Ftag::zoxide() {
  _ZO_FZF_OPTS="$FZF_DEFAULT_OPTS --prompt 'ï Zoxide Tag> ' --no-height +m" zoxide query -i
}
# ]]]

# FUNCTION: Ftag::autojump [[[
# Switch or query directory with autojump
function Ftag::autojump() {
  emulate -LR zsh -o extendedglob
  # Prevent the use of external programs as much as possible
  # autojump -s | tac | awk 'NR>7{print $2}' | fzf --prompt 'ï Jump Tag> ' --no-height
  builtin print -rl -- ${(Oa)${${(@f)"$(autojump -s)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}}[0,-6]} \
    | fzf --prompt 'ï Jump Tag> ' --no-height +m
}
# ]]]

# FUNCTION: Ftag::path::find [[[
# Enter in custom path to switch directories
function Ftag::path::find() {
  builtin print | fzf --prompt 'ï¬ Custom Path> ' --no-height --print-query +m
}
# ]]]

# FUNCTION: Ftag::gitui [[[
# If directory is a git-dir (switch git check to func) then use lazygit or tig
function Ftag::gitui() {
  # gitui -d "${(z)@}" - Freezes -- could add grv
  if { Ftag::dep "lazygit" }; then lazygit -p "${(z)@}"
  elif { Ftag::dep "tig" }; then tig -C "${(z)@}"
  fi
}
# ]]]

# FUNCTION: Ftag::dirstack [[[
# Use fzf to display dirstack and switch directories
function Ftag::dirstack() {
  builtin emulate -L zsh -o extendedglob
  zmodload -Fa zsh/parameter p:dirstack
  zle || {
    if [[ -f ${ZDOTDIR:-$HOME/}/.zshrc ]] {
      builtin source ${ZDOTDIR:-$HOME}/.zshrc
    } elif [[ -f ${HOME}/.config/.zshrc ]] {
      builtin source ${HOME}/.config/.zshrc
    } else {
      +Ftag::msg "{err}unsure where {brgreen}.zshrc{res} is located. Unable to use {yell}dirstack{res}"
    }
  }

  builtin print -rl $dirstack | fzf --no-height --prompt 'ï¬ Dirstack> ' +m
}
# ]]]

# FUNCTION: Ftag::wutag [[[
# $1 = directory; $2 = filename; $3 = tag
# Option to use wutag alongside tag with '-w' or wutag alone with '-ww'
function Ftag::wutag() {
  builtin emulate -L zsh -o noshortloops
  local opt=$1; shift
  if [[ $opt = -s ]]; then
    # set
    wutag -d "${1}/" clear "$2"
    wutag -d "${1}/" set "$2" "$3"
  elif [[ $opt = -a ]]; then
    # add
    wutag -d "${1}/" set "$2" "$3"
  elif [[ $opt = -r ]]; then
    # remove
    wutag -d "${1}/" rm "$2"
  fi
}
# ]]]

# FUNCTION: Ftag::RG [[[
# Open directory and interactively search with ripgrep
# Default action is to open in editor
function Ftag::RG() {
  emulate -LR zsh -o extendedglob
  local RG_PREFIX INITIAL_QUERY header
  local -a selected opts
  # zpty -e RG FZF_DEFAULT_COMMAND="$RG_PREFIX '$INITIAL_QUERY' || true"
  header="C-e â $EDITOR | C-y â Copy | Esc/Q â Quit"
  RG_PREFIX="rg --column --hidden --line-number --no-heading --color=always --smart-case "
  INITIAL_QUERY="${*:-}"
  (
    selected=("$(
      FZF_DEFAULT_COMMAND="$RG_PREFIX '$INITIAL_QUERY' || true" \
        fzf --bind "change:reload:$RG_PREFIX {q} || true" \
          --ansi \
          --disabled \
          --header="$header" \
          --query "$INITIAL_QUERY" \
          --delimiter : \
          --bind 'ctrl-e:execute($EDITOR "$(echo {} | cut -d: -f1)" >/dev/tty </dev/tty)' \
          --bind='ctrl-y:execute-silent(echo {+} | cut -d: -f1 | pbcopy)' \
          --bind='esc:abort,Q:abort' \
          --preview 'bat --style=numbers,header,changes,snip --color=always --highlight-line {2} {1}' \
          --preview-window 'default:right:60%:~1:+{2}+3/2:border-left'
    )")
    selected=( ${(@s.:.)selected} )
    [[ -n "${selected[1]}" ]] && ${EDITOR} "${selected[1]}" "+${selected[2]}"
  )
}
# ]]]

# FUNCTION: Ftag::copy::file [[[
function Ftag::copy::file() {
  builtin emulate -L zsh
  setopt extendedglob typesetsilent noshortloops
  local dest cmd ccmd
  local -a cmds=(cp mv rsync rclone backup)
  cmd=$(builtin print -rl $cmds | fzf --no-height +m)
  ccmd=${cmd/(#m)[[:ascii:]]/${(U)MATCH}} # title-case

  [[ -e $1 ]] || { OS::notify "Selection doesn't exist"; exit 1; }

  [[ $cmd != (rclone|backup) ]] && {
    if { Ftag::dep "zoxide" }; then
      dest=$( _ZO_FZF_OPTS="$FZF_DEFAULT_OPTS --prompt 'ï $ccmd File> ' --no-height" zoxide query -i)
    elif { Ftag::dep "autojump" }; then
      dest=$(builtin print -rl -- ${(Oa)${${(@f)"$(autojump -s)"}//(#m)*/${${(s: :)${MATCH}//[[:space:]]##/ }[2]}}[0,-6]} \
        | fzf --prompt "ï $ccmd File> " --no-height)
    else
      vared -cp "Enter path to $ccmd $1: " dest
    fi
  }

  case $cmd in
    (cp)
      /bin/cp -pri ${(z)1} ${~dest} && OS::notify "$1 was copied to ${~dest}" ;;
    (mv)
      command mv -i ${(z)1} ${~dest} && OS::notify "$1 was moved to ${~dest}" ;;
    (rsync)
      { Ftag::dep "rsync" } && command rsync -aX ${(z)1} ${~dest} && \
        OS::notify "$1 was rsynced to ${~dest}" || {
          +Ftag::msg "{err}{yell}rsync{res} is not installed"; exit 1
        }
      ;;
    (rclone)
      local remote remote_path
      vared -cp "Enter remote name: " remote
      vared -cp "Enter remote path: " remote_path
      { Ftag::dep "rclone" } || { +Ftag::msg "{err}{yell}rclone{res} is not installed"; exit 1; }
      command rclone copy \
      --update \
      --delete-after \
      --exclude ".DS_Store" \
      --exclude .git/ \
      --copy-links \
      --transfers 4 \
      --checkers 8 \
      --contimeout 60s \
      --timeout 300s \
      --retries 3 \
      --low-level-retries 10 \
      ${(z)1} "${remote}:${remote_path}/" && \
        OS::notify "$1 was rcloned to ${remote}:${remote_path}"
        ;;
    (backup)
      # if Ftag::dep "gcp"; then
      #   command gcp -r --force --suffix=.bak ${(z)1} $1.bak
        /bin/cp -pri ${(z)1} $1.bak && OS::notify "$1 was backed up"
      ;;
  esac
}
# ]]]

# FUNCTION: Ftag::gpg [[[
# Open and edit an encrypted file (-e)
# Default is to encrypted if decrypted or vice versa
function Ftag::gpg() {
  builtin emulate -L zsh
  setopt extendedglob typesetsilent noshortloops
  local -a mime opts
  local tmpfile
  zparseopts -a opts -D ${(s::):-e}
  zmodload -Fa zsh/files b:zf_rm b:zf_mv
  # gpg-tui --select key_id
  # TODO: add option for multiple files
  trap "zf_rm -f $tmpfile >/dev/null" EXIT INT TERM
  tmpfile="${TMPDIR:-/tmp}/ftag.dump.$RANDOM"
  mime=( ${(@s./.)${(f)$(file --mime-type --brief "${(z)@}")}} )
  matched=${(M)mime[@]:#(#i)*pgp-encrypted*}
  # Prevent adding armor if user prefers binary encryption
  # If encrypted and edit
  if [[ -n "${matched}" ]] && (( ${+opts[(r)-e]} )) {
    gpg -dq "${(z)@}" > "$tmpfile"
    "${EDITOR:-vim}" "$tmpfile"
    gpg -eq "$tmpfile"
    [[ -f "${tmpfile}.asc" ]] && zf_mv "${tmpfile}.asc" "${(z)@}"
    [[ -f "${tmpfile}.gpg" ]] && zf_mv "${tmpfile}.gpg" "${(z)@}"
    zf_rm -f "$tmpfile"
  # If encrypted, decrypt it
  } elif [[ -n "${matched}" ]] {
    gpg -dq "${(z)@}" > "$tmpfile"
    zf_mv "$tmpfile" "${(z)@}"
  # If decrypted and edit
  } elif [[ -z "${matched}" ]] && (( ${+opts[(r)-e]} )) {
    "${EDITOR:-vim}" "${(z)@}"
  # If decrypted, encrypt it
  } else {
    gpg -eq "${(z)@}"
    [[ -f "${(z)@}.asc" ]] && zf_mv "${(z)@}.asc" "${(z)@}"
    [[ -f "${(z)@}.gpg" ]] && zf_mv "${(z)@}.gpg" "${(z)@}"
  }
}
# ]]]

# FUNCTION: Ftag::twf [[[
# Open directory in twf (similar to fzf)
function Ftag::twf() {
  builtin emulate -L zsh -o extendedglob -o noshortloops
  local -a opts
  local prev file
  prev=${${(M)__ftag[pager]:#bat*}:-cat}
  zparseopts -a opts -D ${(s::):-es}
  if (( ${+opts[(r)-e]} )); then
    file=$(twf -dir "${(z)@}" -previewCmd "${prev} {}")
    [[ -n "$file" ]] && ${EDITOR:-vim} "$file"
  # TODO: use or delete
  elif (( ${+opts[(r)-s]} )); then
    twf -dir "${(z)@}" -previewCmd "${prev} {}"
  fi
}
# ]]]

# FUNCTION: Ftag::dua [[[
# Open directory in dua interactively
function Ftag::dua() {
  builtin emulate -LR zsh
  if { Ftag::dep "dua" } {
    dua i "$@"
  } elif { Ftag::dep "ncdu" } {
    ncdu "$@"
  } else {
    return 1
  }
}
# ]]]

# FUNCTION: Ftag::dust [[[
# View directory/file size in dust or diskus
function Ftag::dust() {
  builtin emulate -LR zsh
  if { Ftag::dep "dust" }; then
    dust -d 1 "$@" | ${(z)__ftag[pager]}
  elif { Ftag::dep "diskus" }; then
    diskus "$@" | ${(z)__ftag[pager]}
  else
    return 1
  fi
}
# ]]]

# FUNCTION: Ftag::forgit [[[
# Open directory if git and use forgit
function Ftag::forgit() {
  builtin emulate -L zsh -o extendedglob
  zmodload -Fa zsh/parameter p:functions
  local -A forgit_cmds
  forgit_cmds=(
    add              "forgit::add"
    log              "forgit::log"
    diff             "forgit::diff"
    ignore           "forgit::ignore"
    reset_head       "forgit::reset::head"
    checkout_file    "forgit::checkout::file"
    checkout_branch  "forgit::checkout::branch"
    checkout_commit  "forgit::checkout::commit"
    clean            "forgit::clean"
    stash            "forgit::stash::show"
    cherry-pick      "forgit::cherry::pick"
    rebase_i         "forgit::rebase"
    fixup            "forgit::fixup"
  )
  Ftag::is_git "$@" &>/dev/null || local git="no"
  if [[ $git != "no" ]]; then
    local reply wfxr
    zle && {
      wfxr=${(f)$(whence -v forgit::log)}; [[ -f "$wfxr" ]] && builtin source "$wfxr"
    } || {
      # If used as a binary and not autoloaded
      # Can test for $ZPFX
      if [[ -f ${ZDOTDIR:-$HOME}/.zinit/plugins//wfxr---forgit/forgit.plugin.zsh ]]; then
        builtin source "${ZDOTDIR:-$HOME}/.zinit/plugins//wfxr---forgit/forgit.plugin.zsh"
      elif [[ -f ${ZDOTDIR:-$HOME}/.zplugin/plugins//wfxr---forgit/forgit.plugin.zsh ]]; then
        builtin source "${ZDOTDIR:-$HOME}/.zplugin/plugins//wfxr---forgit/forgit.plugin.zsh"
      elif [[ -f ${ZDOTDIR:-$HOME}/zinit/plugins//wfxr---forgit/forgit.plugin.zsh ]]; then
        builtin source "${ZDOTDIR:-$HOME}/zinit/plugins//wfxr---forgit/forgit.plugin.zsh"
      elif [[ -f ${ZDOTDIR:-$HOME}/.ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh ]]; then
        builtin source "${ZDOTDIR:-$HOME}/.ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh"
      elif [[ -f ${ZDOTDIR:-$HOME}/ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh ]]; then
        builtin source "${ZDOTDIR:-$HOME}/ohmyzsh/custom/plugins/wfxr-forgit/forgit.plugin.zsh"
      elif [[ -z $ZDOTDIR && -f $HOME/.zshrc ]]; then
        builtin source $HOME/.zshrc
      elif [[ -f ${ZDOTDIR:-$HOME/.config/zsh}/.zshrc ]]; then
        builtin source ${ZDOTDIR:-$HOME/.config/zsh}/.zshrc
      fi
      }

    reply=$(print -rl "${(@k)forgit_cmds}" | fzf --no-height)
    [[ -n "$reply" ]] && {
      (( ${+functions[${forgit_cmds[$reply]}]} )) && \
      FORGIT_FZF_DEFAULT_OPTS="$FORGIT_FZF_DEFAULT_OPTS --no-height" $forgit_cmds[$reply]
    } || OS::notify "Selected function is unavailable" && return 1
  else
      OS::notify "Not a git directory"
  fi
}
# ]]]

# FUNCTION: Ftag::dotbare [[[
# If dir is git use dotbare in that dir; else use on dotfiles
# Brings up own interactive menu
function Ftag::dotbare() {
  builtin emulate -L zsh -o extendedglob
  local -a choice action
  local final
  { Ftag::dep "dotbare" } || return 1
  Ftag::is_git "$@" &>/dev/null || local git="no"
  if [[ $git != "no" ]]; then
    () { setopt localoptions noautopushd; builtin cd -q "${~@}"; } "$@" || return 1
    # setopt localoptions noautopushd
    # builtin cd -q "${~@}" || return 1
    choice=( ${(@f)"$(dotbare)"} )
    action=( ${(@z)choice[1]} )
    final=${action[$(( ${action[(I)dotbare]} + 1 ))]}
    dotbare --git "$final"
  else
    choice=( ${(@f)"$(dotbare)"} )
    action=( ${(@z)choice[1]} )
    final=${action[$(( ${action[(I)dotbare]} + 1 ))]}
    dotbare "$final"
  fi
}
# ]]]

# FUNCTION: Ftag::glow [[[
# Open directory to browse markdown files
function Ftag::glow() {
  integer mdfiles
  mdfiles=$(fd . -e md -d1 "${~@}" | wc -l)
  (( mdfiles > 0 )) && {
    glow "${~@}"; return 0
  } || return 1
}
# ]]]

# FUNCTION: Ftag::open::with [[[
# Prompt user to open file/directory with application
function Ftag::open::with() {
  emulate -L zsh -o extendedglob
  local app choice
  local -a apps=( ${(f)"$(command ls /Applications)"} )
  apps+=( ${(f)"$(command ls /System/Applications)"} )

  Ftag::parse_format "open with"
  local symb="${${${(M)${langinfo[CODESET]:-$LANG}:#(#i)*UTF-8*}:â}:-=>}"
  vared -cp "Type '${FTAG[bryell]}app${FTAG[res]}' to list applications \
    ${FTAG[nl]}Open with $symb " app
  [[ $app = app ]] && choice=$(builtin print -rl $apps | fzf +m --no-height --prompt="App $symb " ) || {
    apps=( ${(@M)apps:#(#i)*$app*} )
    (( $#apps > 1 )) && {
      choice=$(builtin print -rl $apps | fzf +m --no-height --prompt="App $symb ")
    } || choice="$apps[1]"
  }
  [[ -n $choice ]] && command open -a $choice "$@"
  builtin exit $?
}
# ]]]
# ]]] == END: Functions: Actions

# SECTION: Functions: Formatting and Display == [[[
# FUNCTION: Ftag::default_header [[[
# Default header displayed on commands asking for input
# Sub-Zero // ansi_shadow / ANSI_regular / big / doom / small / standard
function Ftag::default_header() {
  emulate -LR zsh -o extendedglob
  local -a fig; integer max color; local -A string
  # Not max, but it works
  zparseopts -D -- s:=string c::=color
  fig=( ${(@f)"$(figlet -f ${FZFTAG_FONT:-standard} ${(v)string[(e)-s]} )"} )
  max=${#${(On)fig}[1]}
  print -nPr "%F{${${color#-c}:-2}}"
  print -lr -- "${(l:(( (COLUMNS+max)/2 )):: :)fig[@]}"
  print -Prn "%f"
  print -Pr -- "%F{1}${(l:COLUMNS::=:):-}%f"
}
# ]]]

# FUNCTION: Ftag::boxes [[[
# Format header display from CLI
function Ftag::boxes() {
  (( ${+commands[boxes]} )) && boxes -d tex-box || {
    cat; +Ftag::msg "{warn}{green}boxes{res} is required to use this feature{res}"
  }
}
# ]]]
# FUNCTION: Ftag::lolcat [[[
function Ftag::lolcat() {
  (( ${+commands[lolcat]} )) && lolcat || {
    cat; +Ftag::msg "{warn}{green}lolcat{res} is required to use this feature{res}"
  }
}
# ]]]
# FUNCTION: Ftag::toilet [[[
function Ftag::toilet() {
  # smblock smmono12
  # toilet -f smmono12 -F border --filter gay
  (( ${+commands[toilet]} )) && {
    toilet -d "${prog_dir}/../fonts" -f ansi_shadow --gay "${(j. .)@}"
  } || {
    cat; +Ftag::msg "{warn}{green}toilet{res} is required to use this feature{res}"
  }
}
# ]]]

# FUNCTION: Ftag::parse_format [[[
# Display with either toilet, lolcat, or boxes
function Ftag::parse_format() {
  builtin emulate -LR zsh
  setopt noshortloops noksharrays
  # Toilet:
  if (( FZFTAG_TOILET )); then
    if (( FZFTAG_LOLCAT )); then
      if (( FZFTAG_BOXES )); then
        Ftag::toilet "${(j. .)@}" | Ftag::boxes | Ftag::lolcat
      else
        Ftag::toilet "${(j. .)@}" | Ftag::lolcat          # tc
      fi
    else
      Ftag::toilet "${(j. .)@}"                           # t
    fi
  # Figlet:
  elif (( FZFTAG_LOLCAT )); then
      if (( FZFTAG_BOXES )); then
        $figlet "${(j. .)@}" | Ftag::boxes | Ftag::lolcat # cb
      else
        $figlet "${(j. .)@}" | Ftag::lolcat               # c
      fi
  elif (( FZFTAG_BOXES )); then
      $figlet "${(j. .)@}" | Ftag::boxes                  # b
  else
    Ftag::default_header -s "${(j. .)@}" -c 2             # default
  fi
}
# ]]]

# FUNCTION: Ftag::vared::formatter [[[
# Display tags for 'vared' in the main loop
# ï ï« ï ï¬ ï® ï¿ ï ï£ î ï ï¡ ï ¸ ï
# ï â± â¯ ï² â£1â¤ âª1â« â¦1â§ îî ââ¸
# (->|=>|â)
function Ftag::vared::formatter() {
  builtin emulate -LR zsh
  setopt extendedglob noshortloops warncreateglobal
  integer adjusted i=1 max=0
  local -a formatted tags tmp; formatted=()
  # local t f; for f (${(@f)@}) { (( $#f > $max )) && max=$#f }
  local t f; for f in "${(@f)${@}}"; do [[ "${#f}" -gt $max ]] && max="${#f}"; done
  adjusted=$(( ${#FTAG[res]} * 2 + ${#FTAG[bcyan]} + ${#FTAG[green]} ))
  for f in "${@}"; do

    formatted=( "${i:+${FTAG[bcyan]}âª$(( i ++ ))â« â¸${FTAG[res]}} ${f:+${FTAG[green]}${f//\%/%%}${FTAG[res]}}" )
    # tmp=( ${(@s:,:)${${(s:---:)${${(@f)"$(tag -Al $f)"}//[[:space:]]##/---}}[2]}} )
    Ftag::map-back "$f"
    tmp=( ${(s:,:)${(@f)$(tag -Al "$reply")[2]}} )
    tags=()

    for t in "${tmp[@]}"; do
      tags+=( "${t:+${FTAG[byell]}ï® ${FTAG[res]}${FTAG[bmagen]}${t}${FTAG[res]}}" )
    done

    print -rl -- ${(l:max+adjusted+7+1+5:)${(r:max+adjusted+7+1:)formatted[@]}}
    print -rl -- ${(l:max+adjusted+7+1+5+4:)${(r:max+adjusted+7+1:)tags[@]}}

  done
}
# ]]]
# ]]] == END: Formatting and Display

# FUNCTION: Ftag::usage [[[
# Display typical help message
function Ftag::usage() {
  emulate -LR zsh
  builtin setopt extendedglob noshortloops noksharrays rcquotes
  Ftag::default_header -s "ftag" -c 13
  +Ftag::msg "{bred}USAGE:{res}"
  +Ftag::msg "{tb}{brcyan}ftag{res} {brmagen}[wsh]{res} {green}<tag>{res}" \
             "{nl}{tb}{green}ftag{res} is an FZF TUI for jdberry's {green}tag{res} on macOS" \
             "{nl}{tb}It uses {yell}figlet{res} by default to display headers, though it is not needed" \
             "{nl}{tb}{green}<tag>{res} is an optional argument, and if used it must be exact. There" \
             "{nl}{tb}are zsh completions to help complete tags. For a fuzzy search, use the {green}--q{res} flag"
  +Ftag::msg "{bred}FLAGS:{res}"

  # Fix these to be one command
  integer longest=0
  local k v
  for k (${(@ok)__FTAG_OPTS}) { (( $#k > $longest )) && longest=$#k }
  adjusted=$(( ${#FTAG[res]} * 2 +  ${#FTAG[green]} * 2 ))
  for k in ${(@ok)__FTAG_OPTS}; do
    # Detect if by a comma
    print -r -- $'\t'${(r:longest+adjusted+4:: :)${(j:, :)${${(s:, :)k[@]}//(#m)*/${FTAG[green]}${MATCH}${FTAG[res]}}}} \
      ${${__FTAG_OPTS[$k]}//(#b)(${(~j:|:)__FTAG_EXTERNAL_OPTS}|-[a-z]##) /${FTAG[yell]}${match[1]}${FTAG[res]} }
  done

  +Ftag::msg "{tb}If a tag is searched for (optional argument), it must be last. Figlet is ran if" \
             "{nl}{tb}toilet isn't specified and vice-versa. The default printing (no flags specified" \
             "{nl}{tb}and figlet installed) looks the nicest. Parameters requiring arguments can be used" \
             "{nl}{tb}with an equals sign (e.g., --path=)"
  +Ftag::msg "{bred}INSIDE FZF:{res}"
  Ftag::parallel "Ftag::show_keys"
}
# ]]]

# FUNCTION: Ftag::show_keys [[[
# Display keybindings within fzf
function Ftag::show_keys() {
  emulate -LR zsh
  builtin setopt extendedglob noshortloops noksharrays rcquotes
  integer longest=0
  local k; for k (${(@ok)__FTAG_KEYBINDINGS}) { (( $#k > $longest )) && longest=$#k; }
  adjusted=$(( ${#FTAG[res]} + ${#FTAG[green]} ))
  for k in ${(@ok)__FTAG_KEYBINDINGS}; do
    print -r -- $'\t'${(r:longest+adjusted+4:)${k:+${FTAG[green]}${k}${FTAG[res]}}} \
      ${${${__FTAG_KEYBINDINGS[$k]}//(#b)(${(~j:|:)__FTAG_EXTERNAL_OPTS})/${FTAG[yell]}${match}${FTAG[res]}}//-- (#m)ACTION_*/${FTAG[brcyan]}${MATCH##--}${FTAG[res]}}
  done
  [[ $1 != -h ]] && Ftag::parallel "Ftag::env_vars"
}
# ]]]

# FUNCTION: Ftag::env_vars [[[
# Display environment variables for ftag
function Ftag::env_vars() {
  emulate -LR zsh
  builtin setopt extendedglob noshortloops noksharrays rcquotes
  +Ftag::msg "{bred}ENVIRONMENT VARIABLES:{res}"
  integer longest=0
  local k v; for v (${(@ok)__FTAG_ENVIRONVARS}) { (( $#v > $longest )) && longest=$#v; }
  adjusted=$(( ${#FTAG[res]} + ${#FTAG[green]} ))
  for k in ${(@ok)__FTAG_ENVIRONVARS}; do
    print -r -- $'\t'${(r:longest+adjusted+4:)${k:+${FTAG[magen]}${k}${FTAG[res]}}} \
      ${${__FTAG_ENVIRONVARS[$k]}//(#b)(${(~j:|:)__FTAG_EXTERNAL_OPTS})/${FTAG[yell]}${match[1]}${FTAG[res]}}
  done
}
# ]]]
# ]]] == END: Functions: Formatting and Display

# ARRAYS: Bindings [[[
local -a __FTAG_EXTERNAL_OPTS
__FTAG_EXTERNAL_OPTS=(
    wutag zoxide autojump lolcat toilet boxes tag fzf glow lazygit gitui gpg
    dua twf dotbare forgit rg bat ftag less pbcopy ctrl alt lf ranger xplr exa
    dragon dust rclone rsync vitag tokei ffsend
)

local -A __FTAG_OPTS
__FTAG_OPTS=(
    "-w, --wutag"          "Also tag files with wutag (-ww only uses wutag)"
    "-q, --query <query>"  "Start fzf with a query"
    "-p, --path <path>"    "Enter a path for ftag to start"
    "-z, --zoxide"         "Use zoxide to select directory to use tags (only shows tagged files)"
    "-j, --jump"           "Use autojump to select directory to use tags (only shows tagged files)"
    "-b, --boxes"          "Add a box around header with boxes"
    "-T, --lolcat"         "Color the header with lolcat"
    "-t, --toilet"         "Color and format the header with toilet"
    "-l, --local"          "Use tag in a local directory"
    "-n, --nocolor"        "Don't use colored output"
    "-C, --color <color>"  "Specify list of colors to use (use -C ls|list to list colors)"
    "-s, --sort"           "Sort desc with d|desc|++, sort ascending with a|asc|+"
    "-N, --nofzf"          "No fzf, however not a wrapper"
    "-W, --wrapper <cmds>" "No fzf, but is a wrapper and can use tag commands"
    "-f, --font <font>"    "Use custom font with figlet (some are provided)"
    "-h, --help"           "Display this help message"
    "-c, --config <conf>"  "Specify configuration file"
    "-d, --dump"           "Dump configuration (mappings, actions, keyfile). Optional parameter of p|pager (no hyphen) to view in pager"
    "-v, --verbose"        "Display verbosity (-vvv is max; only used with wrapper as of now)"
)

local -A __FTAG_KEYBINDINGS
__FTAG_KEYBINDINGS=(
    A   "Add/append tags -- ACTION_ADD"
    D   "Delete/remove tags -- ACTION_REMOVE"
    E   "Edit selected tags with \$EDITOR -- ACTION_EDIT"
    F   "Open directory with file manager in which tagged file resides -- ACTION_FILEMANAGER"
    G   "Switch to global mode (i.e., default mode/all tags on filesystem) -- ACTION_GLOBAL"
    I   "Open gitui/lazygit if directory is a git-dir -- ACTION_GIT"
    J   "Switch to autojump query to select path to list tags -- ACTION_AUTOJUMP"
    L   "Switch to local mode (i.e., current directory) -- ACTION_LOCAL"
    O   "Open file in external program based on extension -- ACTION_OPEN"
    P   "Toggle preview of file or directory -- ACTION_PREVIEW"
    Q   "Quit ftag -- ACTION_QUIT"
    R   "Reload the tag search -- ACTION_RELOAD"
    S   "Set tags (overwrites) -- ACTION_SET"
    U   "Show tag usage -- ACTION_USAGE"
    V   "Toggle bat to view file -- ACTION_VIEW"
    Z   "Switch to zoxide query to select path to list tags -- ACTION_ZOXIDE"
    C-b "If git-dir, open dotbare to select action -- ACTION_DOTBARE"
    C-d "Open directory in dua interactive mode -- ACTION_DUA"
    C-e "Edit a gpg-encrypted file -- ACTION_GPG_EDIT"
    C-f "If git-dir, open forgit to select action -- ACTION_FORGIT"
    C-g "Encrypt or decrypt a file with gpg. If encryped, decrypted and vice versa -- ACTION_GPG"
    C-o "Open directory in finder -- ACTION_FINDER"
    C-p "Switch to custom path -- ACTION_PATH"
    C-r "Open directory with rg in an interactive mode -- ACTION_RIPGREP"
    C-s "Switch directories using dirstack -- ACTION_DIRSTACK"
    C-t "Open directory in twf to edit file -- ACTION_TWF_EDIT"
    C-v "Toggle a TUI program to view file -- ACTION_EXTERNALVIEW"
    C-w "Open directory with glow if dir contains markdown files -- ACTION_GLOW"
    C-y "Copy file or directory name -- ACTION_COPY"
    M-c "Copy/move/rsync/rclone/backup file or directory -- ACTION_COPY_FILE"
    M-d "Be prompted to delete file -- ACTION_DELETE"
    M-f "Use ffsend to upload file(s) -- ACTION_FFSEND"
    M-i "View director(y|ies) stats with tokei -- ACTION_TOKEI"
    M-p "Open a popup window to copy file with dragon -- ACTION_DRAGON_SOURCE"
    M-s "View directory size in dust -- ACTION_DUST"
    M-t "Open directory in vitag to edit tags -- ACTION_VITAG"
    M-w "Prompted with what to open file/dir with -- ACTION_OPEN_WITH"
    "?" "Show key help message -- ACTION_HELP"
)

typeset -gAH __FTAG_ENVIRONVARS
__FTAG_ENVIRONVARS=(
    FTAG_PAGER                                      'Pager to view file or usage (default: bat, less)'
    FTAG_COPY                                       'Copy command to copy path to clipboard (default: pbcopy)'
    FTAG_MODIFIER                                   'Modifier to bind with fzf (default: ctrl)'
    FTAG_ALT                                        'Alternative key bind with fzf (default: alt)'
    FTAG_FILEMANAGER                                'File manager to open in ftag (default: lf, ranger, xplr)'
    FTAG_FILE_PREV                                  'Fzf preview for files (default: bat)'
    FTAG_DIR_PREV                                   'Fzf preview for directories (default: exa)'
    FTAG_KEYFILE                                    'File of keybinding configuration (-g|--genconfig will generate an example $XDG_CONFIG_HOME/ftag/config)'
    FTAG_DIR_MAP                                    'File of directory mappings for the %shortening'
    FTAG_COLORS                                     'List of no more than 3 colors to colorize output'
    "zstyle ':ftag:' key-file <location>"           'Alternative way to specify configuration (this has higher priority)'
    "zstyle ':ftag:' fzf-command fzf_command <cmd>" 'Alternate fzf command (e.g., fzf-tmux)'
    "zstyle ':ftag:' fzf-bindings bind <bindings>"  'List of additional fzf bindings (not actions), e.g., alt-shift-up:preview-up'
    "zstyle ':ftag:' fzf-flags <flags>"             'Additional fzf flags to main command'
    "zstyle ':ftag:' fzf-file-preview <prev_cmd>"   'Alternative way to specify FTAG_FILE_PREV (higher priority)'
    "zstyle ':ftag:' fzf-dir-preview <prev_cmd>"    'Alternative way to specify FTAG_DIR_PREV (higher priority)'
    "zstyle ':ftag:' fzf-modifier <mod>"            'Alternative way to specify FTAG_MODIFIER (higher priority)'
    "zstyle ':ftag:' fzf-alt <alt>"                 'Alternative way to specify FTAG_ALT (higher priority)'
    "zstyle ':ftag:' copy-cmd <cmd>"                'Alternative way to specify FTAG_COPY (higher priority)'
    "zstyle ':ftag:' pager <cmd>"                   'Alternative way to specify FTAG_PAGER (higher priority)'
    "zstyle ':ftag:' file-manager <fm>"             'Alternative way to specify FTAG_FILEMANAGER (higher priority)'
    "zstyle ':ftag:' colors <colors>"               'Alternative way to specify FTAG_COLORS (higher priority)'
)
# ]]]

# SECTION: == Imports / Setting Variables == [[[
zmodload -Fa zsh/zutil b:zparseopts \
  || { +Ftag::msg "{err}{green}zsh/zutil{res} is required to use this program{res}"; exit 1; }

zmodload -Fa zsh/parameter p:commands p:parameters \
  || { +Ftag::msg "{err}{green}zsh/parameter{res} is requred to use this program{res}"; exit 1; }

zmodload -Fa zsh/langinfo p:langinfo \
  || [[ -n "$LANG" ]] \
  || +Ftag::msg "{warn}{green}zsh/langinfo{res} is recommended to use this program{res}"

# tput $COLUMNS
zmodload zsh/terminfo 2>/dev/null
zmodload zsh/termcap 2>/dev/null

# a all = not used
# Set query as optional args to prevent errors
local -A opts
local -a cfont sort wtag query verbose optpath ccolor config dump
typeset -gaH wrapper
# FIX: error is never hit
zparseopts -D -A opts h -help b -boxes T -lolcat t -toilet g -genconfig \
    l -local z -zoxide j -jump n -nocolor N -nofzf {d,-dump}::=dump {W,-wrapper}:=wrapper \
    {f,-font}::=cfont {p,-path}:=optpath {q,-query}::=query {C,-color}:=ccolor \
    {c,-config}:=config {w,-wutag}+=wtag {s,-sort}::=sort {v,-verbose}+=verbose || {
      Ftag::usage; exit 1;
    }

typeset -gAH FTAG
FTAG=(
  red    $'\e[38;5;1m'  bred   $'\e[01;31m' brred   $'\e[38;5;9m'
  green  $'\e[38;5;2m'  bgreen $'\e[01;32m' brgreen $'\e[38;5;10m'
  yell   $'\e[38;5;3m'  byell  $'\e[01;33m' bryell  $'\e[38;5;11m'
  blue   $'\e[38;5;4m'  bblue  $'\e[01;34m' brblue  $'\e[38;5;12m'
  magen  $'\e[38;5;5m'  bmagen $'\e[01;35m' brmagen $'\e[38;5;13m'
  cyan   $'\e[38;5;6m'  bcyan  $'\e[01;36m' brcyan  $'\e[38;5;14m'
  und    $'\e[4m'       bold   $'\e[1m'     bg      $'\e[3m'
  tb     $' \tÂ '        nl     $'\n'        res     $'\e[0m'
)

# ??
# local -A colors fg bg fg_bold bg_bold fg_no_bold
# colors=(); fg=(); bg=(); fg_bold=(); bg_bold=(); reset_color=""
# autoload colors
# colors
typeset -gAH __FTAG_ANSI
__FTAG_ANSI=(
  red   "$fg_no_bold[red]"     bred   "$fg_bold[red]"     bgred   "$bg[red]"
  green "$fg_no_bold[green]"   bgreen "$fg_bold[green]"   bggreen "$bg[green]"
  yell  "$fg_no_bold[yellow]"  byell  "$fg_bold[yellow]"  bgyell  "$bg[yellow]"
  blue  "$fg_no_bold[blue]"    bblue  "$fg_bold[blue]"    bgblue  "$bg[blue]"
  magen "$fg_no_bold[magenta]" bmagen "$fg_bold[magenta]" bgmagen "$bg[magenta]"
  cyan  "$fg_no_bold[cyan]"    bcyan  "$fg_bold[cyan]"    bgcyan  "$bg[cyan]"
  res   "$reset_color"
)

Ftag::opts "h help" && {
  Ftag::usage
  exit 0
}

local figlet
Ftag::dep -e "tag"
Ftag::dep "figlet" && figlet="figlet" || figlet="cat"

# Has to be global when program is sourced on second loop
typeset -gH FZFTAG_QUERY
FZFTAG_QUERY=${${${query##-(q|-query(=|))}[-1]}:-} # fzf query
export FZFTAG_QUERY

typeset -gH FZFTAG_PATH
# This array is split instead of above, where it's joined
FZFTAG_PATH=${${${${(@)optpath##-(p|-path(=|))}[-1]}//=/}:-} # fzf path
export FZFTAG_PATH

local conf
conf=${${~${${config##-(c|-config(=|))}[-1]}//=/}:-}

sort=${${${${sort##-(s|-sort(=|))}[-1]}//=/}:-}
[[ -n $sort && $sort != (+|a|asc|++|d|desc) ]] && {
  +Ftag::msg "{err}sorting must be (+|a|asc) for ascending or (++|d|desc) for descending"
  exit 1
}

# List colors
ccolor=( ${${(@s:,:)${${(A@)ccolor##-(C|-color(=|))}[-1]//=/}}:-} )
[[ $ccolor = (ls|list) ]] && {
  for k ( "${(@kon)FTAG[(I)^(und|bold|res|tb|nl)]}" ); do
    local i=$FTAG[$k]
    print "${FTAG[res]}${(r:14:: :):-$k:} $i###########"
  done && exit 0
}

typeset -g +h LESS
local space
space="[[:space:]]#"
# Prevent -r from being added twice; -F prevents paging if less than screen size
LESS=${(j. .)${${(@)${(s: :)LESS}}//(${~space}-r${~space}|${~space}-F${~space})/}}
export LESS="-r $LESS"

# Add path before starting to check dependencies
(( ! ${path[(I)/usr/local/bin]} )) && {
  path+=( "/usr/local/bin" )
  trap 'path=( "${path[@]:#/usr/local/bin}" )' INT EXIT
}

[[ -n $ZPFX && ${path[(I)$ZPFX/bin]} -ne 0 ]] && {
  path+=( "$ZPFX/bin" )
  trap 'path=( "${path[@]:#$ZPFX/bin}" )' INT EXIT
}
# ]]] == END: Setting Variables

# SECTION: == Config == [[[
() {
  builtin emulate -LR zsh
  setopt nullglob noksharrays extendedglob typesetsilent warncreateglobal
  zmodload -Fa zsh/files b:zf_mkdir
  zmodload -Fa zsh/zutil b:zstyle
  local keyfile bind fzf_flags ph
  typeset -gHA __ftag
  typeset -gx FTAG_FILE_PREV FTAG_DIR_PREV FTAG_KEYFILE FTAG_COPY FTAG_MODIFIER FTAG_ALT

  # print -- ${${jobstates[(R)running:*]/#*:/}/%=*/}

  keyfile="${XDG_CONFIG_HOME:-$HOME/.config}/ftag/config.ini"
  __ftag[extra_binds]="alt-shift-down:preview-down,alt-shift-up:preview-up"

  Ftag::declare -A '\
    FTAG_DIR_MAP=(
      "$HOME/.config/zsh"     %ZDOTDIR
      "$HOME/.config"         %XDG_CONFIG_HOME
      "$HOME/.cache"          %XDG_CACHE_HOME
      "$HOME/.local/share"    %XDG_DATA_HOME
      "$HOME/bin"             %XDG_BIN_HOME
      "$HOME/ghq"             %GHQ
      "$HOME/github"          %GITHUB
      "$HOME/projects/github" %PR_GITHUB
      "$HOME/Downloads"       %DOWNLOADS
      "$HOME/Documents"       %DOCUMENTS
      "$HOME/Desktop"         %DESKTOP
      "$HOME/Pictures"        %PICTURES
      "$HOME/Library"         %LIBRARY
      "$HOME/Applications"    %APPLICATIONS
      "$HOME/Music"           %MUSIC
      "$HOME/Movies"          %MOVIES
      "$HOME/vimwiki"         %WIKI_DIR
      "/usr/local"            %LOCAL_USR
      "$HOME"                 %HOME
    )'

  readonly TTY_REDIRECTION="< /dev/tty > /dev/tty 2>&1"
  readonly FTAG_PRINT="+print-query"
  readonly FTAG_INTERNAL="+reload(env _FZFTAG_INTERNAL=reload $prog)"
  readonly FTAG_RELOAD="+reload(env _FZFTAG_RELOAD=true $prog)"
  readonly FTAG_CHPROMPT="+change-prompt"

  # local cf
  # local lastcache_file="${TMPDIR:-/tmp}/ftag_lastcache"
  # [[ -f $lastcache_file ]] && __ftag[lastcache]="$(<$lastcache_file)" || __ftag[lastcache]=0

  # zstyle -s ":ftag:*" cache-file ${cf::=__ftag[cachefile]} || {
  #   ! Ftag::declare "FTAG_CACHEFILE=${XDG_CONFIG_HOME:-$HOME/.config}/ftag/config" && __ftag[cachefile]=$FTAG_CACHEFILE || {
  #     __ftag[cachefile]="${XDG_DATA_HOME:-$HOME/.local/share}/ftag/cache"
  #     [[ ! -d $~__ftag[cachefile]:h ]] && {
  #       zf_mkdir -p $~__ftag[cachefile]:h
  #     }
  #   }
  # }

  # tmp=( ${~tmp::=__ftag[cachefile](ms-$(( ${(%)tmp::="%D{%s}"} - ${__ftag[lastcache]:-0} )))} )
  # (( $#tmp )) && builtin source $~__ftag[cachefile] && echo 'sourced'
  # print -r -- ${(%)tmp::="%D{%s}"} > "${~lastcache_file}"

  # print -r -- "FTAG_KEYBINDINGS=( ${${(kv@qq)^^FTAG[(I)key__*]}//key__/} )" > $~__ftag[cachefile]
  # print -rl -- ${(kv@qq)^^FTAG[(I)(key|map|action)__*]}

  # Precedence of configuration
  # key-file | FTAG_KEYFILE => zstyle => environment variables
  Ftag::zstyle -s fzf-command       ${ph::=__ftag[fzf_command]} || : ${__ftag[fzf_command]::=fzf}
  Ftag::zstyle -a fzf-bindings      bind                        && __ftag[extra_binds]+=,${(j:,:)bind}
  Ftag::zstyle -a fzf-flags         fzf_flags                   && : ${__ftag[fzf_flags]::=${(j: :)fzf_flags}}

  Ftag::zstyle -s fzf-file-preview ${ph::=__ftag[file_prev]} || : ${__ftag[file_prev]::=${FTAG_FILE_PREV:-bat --style=numbers --color=always}}
  Ftag::zstyle -s fzf-dir-preview  ${ph::=__ftag[dir_prev]}  || \
    : ${__ftag[dir_prev]::=${FTAG_DIR_PREV:-${${commands[exa]:+exa -TL 3 --color=always --icons}:-${commands[tree]:+LANG=en_US.utf-8 tree -L 3 --charset utf-8}}}}
  Ftag::zstyle -s fzf-modifier     ${ph::=__ftag[fzf_mod]}   || : ${__ftag[fzf_mod]::=${FTAG_MODIFIER:-ctrl}}
  Ftag::zstyle -s fzf-alt          ${ph::=__ftag[fzf_alt]}   || : ${__ftag[fzf_alt]::=${FTAG_ALT:-alt}}

  Ftag::zstyle -s copy-cmd         ${ph::=__ftag[copy_cmd]} || : ${__ftag[copy_cmd]::=${FTAG_COPY:-pbcopy}}
  Ftag::zstyle -s pager            ${ph::=__ftag[pager]}    || : ${__ftag[pager]::=${FTAG_PAGER:-${${${commands[bat]}:+bat --paging=always -f}:-less}}}
  Ftag::zstyle -s file-manager     ${ph::=__ftag[fmngr]}    || : ${__ftag[fmngr]::=${FTAG_FILEMANAGER:-${commands[lf]:-${commands[ranger]}:-${commands[xplr]}}}}
  Ftag::zstyle -s colors           ${ph::=__ftag[colors]}   || : ${__ftag[colors]::=${FTAG_COLORS:-${(As: :):-bmagen blue green}}}
  Ftag::zstyle -s key-file         ${ph::=__ftag[keyfile]}  || : ${__ftag[keyfile]::=${FTAG_KEYFILE:-${0:A:h}/ftag}}

  # CLI specification trumps zstyle
  [[ -n "$conf" ]] && __ftag[keyfile]="$conf"

  # Fzf reloads automatically when locally searching
  # However global requires a manual reload unless you wait just a second
  # The redirection, reload, and print seems to help some
  typeset -gA FTAG_ACTIONS
  : ${FTAG_ACTIONS[ACTION_ADD]:=execute(env FZFTAG_ACTION=add "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_RELOAD}"}
  : ${FTAG_ACTIONS[ACTION_SET]:=execute(env FZFTAG_ACTION=set "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_RELOAD}"}
  : ${FTAG_ACTIONS[ACTION_EDIT]:=execute(env FZFTAG_ACTION=edit "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_RELOAD}"}
  : ${FTAG_ACTIONS[ACTION_REMOVE]:=execute(env FZFTAG_ACTION=remove "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_RELOAD}"}
  : ${FTAG_ACTIONS[ACTION_VITAG]:=execute(env FZFTAG_ACTION=vitag "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_USAGE]:=execute(env FZFTAG_ACTION=usage "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}

  : ${FTAG_ACTIONS[ACTION_COPY_FILE]:=execute(env FZFTAG_ACTION=copy-file "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_FINDER]:=execute(env FZFTAG_ACTION=open-finder "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_OPEN]:=execute(env FZFTAG_ACTION=open "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_OPEN_WITH]:=execute(env FZFTAG_ACTION=open-with "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_VIEW]:=execute(env FZFTAG_ACTION=bat-view "$prog" \{+f\})}
  : ${FTAG_ACTIONS[ACTION_EXTERNALVIEW]:=execute(env FZFTAG_ACTION=external-view "$prog" \{+f\})}
  : ${FTAG_ACTIONS[ACTION_COPY]:=execute-silent(env FZFTAG_ACTION=copy "$prog" \{+f\})}
  : ${FTAG_ACTIONS[ACTION_DELETE]:=execute(env FZFTAG_ACTION=delete "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_FILEMANAGER]:=execute(env FZFTAG_ACTION=file-manager "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}

  : ${FTAG_ACTIONS[ACTION_GIT]:=execute(env FZFTAG_ACTION=git "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_GPG_EDIT]:=execute(env FZFTAG_ACTION=gpg-edit "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_GPG]:=execute(env FZFTAG_ACTION=gpg "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_DUA]:=execute(env FZFTAG_ACTION=dua "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_DUST]:=execute(env FZFTAG_ACTION=dust "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_TWF_EDIT]:=execute(env FZFTAG_ACTION=twf-edit "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_RIPGREP]:=execute(env FZFTAG_ACTION=ripgrep "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_FORGIT]:=execute(env FZFTAG_ACTION=forgit "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_DOTBARE]:=execute(env FZFTAG_ACTION=dotbare "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_GLOW]:=execute(env FZFTAG_ACTION=glow "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_FFSEND]:=execute(env FZFTAG_ACTION=ffsend "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_TOKEI]:=execute(env FZFTAG_ACTION=tokei "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_DRAGON_SOURCE]:=execute(env FZFTAG_ACTION=dragon-source "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}

  : ${FTAG_ACTIONS[ACTION_DIRSTACK]:=execute(env FZFTAG_STATE_CHANGE=dirstack "$prog" )"${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}"(ï¬ Dirstack Tag> )}
  : ${FTAG_ACTIONS[ACTION_LOCAL]:=execute(env FZFTAG_STATE_CHANGE=local "$prog" )"${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}"(ï¬ Local Tag> )}
  : ${FTAG_ACTIONS[ACTION_PATH]:=execute(env FZFTAG_STATE_CHANGE=path "$prog" )"${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}"(ï¬ Path Tag> )}
  : ${FTAG_ACTIONS[ACTION_GLOBAL]:=execute(env FZFTAG_STATE_CHANGE=global "$prog" )"${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}"(ï¬ Global Tag> )}
  : ${FTAG_ACTIONS[ACTION_ZOXIDE]:=execute(env FZFTAG_STATE_CHANGE=zoxide "$prog" )"${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}"(ï Zoxide Tag> )}
  : ${FTAG_ACTIONS[ACTION_AUTOJUMP]:=execute(env FZFTAG_STATE_CHANGE=autojump "$prog" )"${(z)FTAG_INTERNAL}${FTAG_CHPROMPT}"(ï Jump Tag> )}

  : ${FTAG_ACTIONS[ACTION_RELOAD]:=reload(env _FZFTAG_INTERNAL=reload "$prog")}
  : ${FTAG_ACTIONS[ACTION_PREVIEW]:=toggle-preview}
  : ${FTAG_ACTIONS[ACTION_HELP]:=execute(env _FZFTAG_SHOW=keys "$prog" | "${(z)__ftag[pager]}" )"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_QUIT]:=abort}

  : ${FTAG_ACTIONS[ACTION_TOGGLE_DOWN]:=toggle+down}
  : ${FTAG_ACTIONS[ACTION_TEST]:=execute(env FZFTAG_ACTION=test "$prog" \{+f\} "${(z)TTY_REDIRECTION}")"${(z)FTAG_PRINT}"}
  : ${FTAG_ACTIONS[ACTION_TWF_SWITCH]:=execute(env FZFTAG_STATE_CHANGE=twf-switch "$prog" )"${(z)FTAG_RELOAD}${FTAG_CHPROMPT}"(TWF Tag>)}

  typeset -gA FTAG_KEYBINDINGS
  # builtin zstyle ":ftag:*" bindings default
  : ${FTAG_KEYBINDINGS[T]:=$FTAG_ACTIONS[ACTION_TEST]}

  : ${FTAG_KEYBINDINGS[A]:=$FTAG_ACTIONS[ACTION_ADD]}
  : ${FTAG_KEYBINDINGS[S]:=$FTAG_ACTIONS[ACTION_SET]}
  : ${FTAG_KEYBINDINGS[E]:=$FTAG_ACTIONS[ACTION_EDIT]}
  : ${FTAG_KEYBINDINGS[D]:=$FTAG_ACTIONS[ACTION_REMOVE]}
  : ${FTAG_KEYBINDINGS[U]:=$FTAG_ACTIONS[ACTION_USAGE]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_alt]}-t]:=$FTAG_ACTIONS[ACTION_VITAG]}

  : ${FTAG_KEYBINDINGS[F]:=$FTAG_ACTIONS[ACTION_FILEMANAGER]}
  : ${FTAG_KEYBINDINGS[I]:=$FTAG_ACTIONS[ACTION_GIT]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-s]:=$FTAG_ACTIONS[ACTION_DIRSTACK]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-b]:=$FTAG_ACTIONS[ACTION_DOTBARE]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-f]:=$FTAG_ACTIONS[ACTION_FORGIT]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-e]:=$FTAG_ACTIONS[ACTION_GPG_EDIT]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-g]:=$FTAG_ACTIONS[ACTION_GPG]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_alt]}-c]:=$FTAG_ACTIONS[ACTION_COPY_FILE]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-d]:=$FTAG_ACTIONS[ACTION_DUA]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_alt]}-s]:=$FTAG_ACTIONS[ACTION_DUST]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-t]:=$FTAG_ACTIONS[ACTION_TWF_EDIT]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-r]:=$FTAG_ACTIONS[ACTION_RIPGREP]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-o]:=$FTAG_ACTIONS[ACTION_FINDER]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-w]:=$FTAG_ACTIONS[ACTION_GLOW]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_alt]}-i]:=$FTAG_ACTIONS[ACTION_TOKEI]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_alt]}-f]:=$FTAG_ACTIONS[ACTION_FFSEND]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_alt]}-p]:=$FTAG_ACTIONS[ACTION_DRAGON_SOURCE]}
  : ${FTAG_KEYBINDINGS[O]:=$FTAG_ACTIONS[ACTION_OPEN]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_alt]}-w]:=$FTAG_ACTIONS[ACTION_OPEN_WITH]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_alt]}-d]:=$FTAG_ACTIONS[ACTION_DELETE]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-p]:=$FTAG_ACTIONS[ACTION_PATH]}
  : ${FTAG_KEYBINDINGS[L]:=$FTAG_ACTIONS[ACTION_LOCAL]}
  : ${FTAG_KEYBINDINGS[G]:=$FTAG_ACTIONS[ACTION_GLOBAL]}
  : ${FTAG_KEYBINDINGS[Z]:=$FTAG_ACTIONS[ACTION_ZOXIDE]}
  : ${FTAG_KEYBINDINGS[J]:=$FTAG_ACTIONS[ACTION_AUTOJUMP]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-y]:=${(z)FTAG_ACTIONS[ACTION_COPY]}}
  : ${FTAG_KEYBINDINGS[V]:=$FTAG_ACTIONS[ACTION_VIEW]}
  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-v]:=$FTAG_ACTIONS[ACTION_EXTERNALVIEW]}

  : ${FTAG_KEYBINDINGS[R]:=$FTAG_ACTIONS[ACTION_RELOAD]}
  : ${FTAG_KEYBINDINGS[P]:=$FTAG_ACTIONS[ACTION_PREVIEW]}
  : ${FTAG_KEYBINDINGS[Q]:=$FTAG_ACTIONS[ACTION_QUIT]}
  : ${FTAG_KEYBINDINGS[esc]:=$FTAG_ACTIONS[ACTION_QUIT]}
  : ${FTAG_KEYBINDINGS[?]:=$FTAG_ACTIONS[ACTION_HELP]}

  : ${FTAG_KEYBINDINGS[${__ftag[fzf_mod]}-s]:=$FTAG_ACTIONS[ACTION_TWF_SWITCH]}

  [[ $~__ftag[keyfile] != "${0:A:h}/ftag" ]] && {
    [[ ! -r $~__ftag[keyfile] ]] && { +Ftag::msg "{err}${~__ftag[keyfile]} is not readable; aborting ..."; exit 1; }
    local -a match mbegin mend
    local -A out
    local k

    Ftag::ini::read "$~__ftag[keyfile]" out

    for k in "${(@k)out}"; do
      [[ "$k" = \<env_vars\>* ]] && {
        typeset -g "${k#\<env*_*_}=${(v)out[$k]}"
      }

      [[ "$k" = \<keybindings\>* ]] && {
        local key=${${k#\<key*_}/(#b)(M|C)-/${${${(M)match:#M}:+${FTAG_ALT:-$__ftag[fzf_alt]}}:-${FTAG_MODIFIER:-$__ftag[fzf_mod]}}-}
        FTAG_KEYBINDINGS[$key]=$FTAG_ACTIONS[${(v)out[$k]}]
      }

      [[ "$k" = \<dir_map\>* ]] && {
        local dir="${out[$k]}"
        [[ $dir = \~/* ]] && dir=${~dir} || dir=${(e)dir}
        FTAG_DIR_MAP[$dir]="%${k##\<dir*_}"
      }

      [[ "$k" = \<fzf\>* ]] && {
        [[ "$k" = *fzf_command ]]  && { __ftag[fzf_command]="${(v)out[$k]}" }
        [[ "$k" = *fzf_flags ]]    && { __ftag[fzf_flags]="${(j: :)${${(Av)out[$k]}//,/}}" }
        [[ "$k" = *fzf_bindings ]] && { __ftag[extra_binds]+=",${(j:,:)${(Av)out[$k]}}" }
      }

      [[ "$k" = \<colors\>* ]] && {
        # Specify new key to prevent having 3+ colors
        __ftag[kcolors]+="${(Av)out[$k]} "
      }
    done
  }

  [[ -n "$__ftag[kcolors]" ]] && __ftag[colors]=$__ftag[kcolors]

  local x
  [[ -n $ccolor ]] && {
    for x (${(s: :)ccolor}) {
      [[ -z ${(M)x:#${(~j:|:)${(@k)FTAG[(I)(^und|bold|res|tb|nl)]}}} ]] && {
        +Ftag::msg "{err}{red}$x{res} is an invalid color. Use {yell}--colors ls{res} to list colors"; exit 1
      }
    }
  } || {
    for x (${(As: :)__ftag[colors]}) {
      [[ -z ${(M)x:#${(~j:|:)${(@k)FTAG[(I)(^und|bold|res|tb|nl)]}}} ]] && {
        +Ftag::msg "{err}{red}$x{res} is an invalid color. Use {yell}--colors ls{res} to list colors"; exit 1
      }
    }
  }

  (( $#ccolor > 3 ))       && {
    local dot="${${${(M)${langinfo[CODESET]:-$LANG}:#(#i)*UTF-8*}:+}:--}"
    +Ftag::msg "{err}specify no more than 3 colors." \
      "{nl}  $dot {bmagen}Color 1{res} = tags" \
      "{nl}  $dot {blue}Color 2{res} = tag separator" \
      "{nl}  $dot {green}Color 3{res} = %DIR_MAP shortener"
    exit 1
  }

  # Do this instead of only use ccolor to provide 3 colors even if only one is specified
  typeset -gH __c1 __c2 __c3 __bc3
  [[ -n $ccolor[1] ]] && __c1="${FTAG[$ccolor[1]]}" || __c1="${FTAG[${${(s: :)__ftag[colors]}[1]}]}"
  [[ -n $ccolor[2] ]] && __c2="${FTAG[$ccolor[2]]}" || __c2="${FTAG[${${(s: :)__ftag[colors]}[2]}]}"
  [[ -n $ccolor[3] ]] && __c3="${FTAG[$ccolor[3]]}" || __c3="${FTAG[${${(s: :)__ftag[colors]}[3]}]}"
  [[ -n $ccolor[3] ]] && __bc3="${FTAG[${ccolor[3]:+b${ccolor[3]}}]}"

  [[ -n $dump ]] && {
    {
      local MATCH k v j; integer MBEGIN MEND long=0 adj=0; local -a tmp match mbegin mend
      # Maybe too many loops here? Not slow though
      tmp=( ${(@)${(@v)FTAG_KEYBINDINGS}//(#m)*/${(k)FTAG_KEYBINDINGS[(r)${(b)MATCH}]}\=${(@k)FTAG_ACTIONS[(r)${(b)MATCH}]}} )
      for k v (${(@kv)FTAG_KEYBINDINGS}) { __ftag[key__${k}]=$v; }
      for k v (${(@kv)FTAG_ACTIONS})     { __ftag[action__${k#ACTION_}]=$v; }
      for j (${tmp[@]})                  { __ftag[map__${${(s:=:)j}[1]}]=${${(s:=:)j}[2]}; }
      for k (${(@ok)__ftag})             { (( $#k > $long )) && long=$#k; }

      # for f (${(@k)FTAG_KEYBINDINGS} ${(@k)FTAG_ACTIONS} ${(@k)^^__ftag[map__*]}) { (( $#k > $long )) && long=$#k; }
      adj=$(( ${#${:-key__}} + ${#FTAG[red]} * 2 + ${#FTAG[res]} * 2 ))

      +Ftag::msg "{red}${(l:COLUMNS::=:):-}{res}"
      +Ftag::msg "{bgreen}${(l:COLUMNS/2:: :):-${FTAG[und]}KEYBINDINGS}{res}"
      +Ftag::msg "{red}${(l:COLUMNS::=:):-}{res}"
      for k in "${(@ok)^^__ftag[(I)key__*]}"; do
        print -rn -- "${(r:long+adj+1:: :)k/key__/${FTAG[red]}key__${FTAG[res]}${FTAG[brcyan]}}${FTAG[res]} \
          ${__ftag[$k]//(#b)(FZFTAG_[^=]#)(=)([^[:blank:]]#)/${FTAG[yell]}${match[1]}${FTAG[res]}${match[2]}${FTAG[brgreen]}${match[3]}${FTAG[res]}}"
        print
      done
      +Ftag::msg "{red}${(l:COLUMNS::=:):-}{res}"

      +Ftag::msg "{bgreen}${(l:COLUMNS/2:: :):-${FTAG[und]}ACTIONS}{res}"
      +Ftag::msg "{red}${(l:COLUMNS::=:):-}{res}"
      for k in "${(@ok)^^__ftag[(I)action__*]}"; do
        print -rn -- "${(r:long+adj+1:: :)k/action__/${FTAG[red]}action__${FTAG[res]}${FTAG[brcyan]}}${FTAG[res]} \
          ${__ftag[$k]//(#b)(FZFTAG_[^=]#)(=)([^[:blank:]]#)/${FTAG[yell]}${match[1]}${FTAG[res]}${match[2]}${FTAG[brgreen]}${match[3]}${FTAG[res]}}"
        print
      done
      +Ftag::msg "{red}${(l:COLUMNS::=:):-}{res}"

      +Ftag::msg "{bgreen}${(l:COLUMNS/2:: :):-${FTAG[und]}MAP}{res}"
      +Ftag::msg "{red}${(l:COLUMNS::=:):-}{res}"
      for k in "${(@ok)^^__ftag[(I)map__*]}"; do
        print -rn -- "${(r:long+adj+1:: :)k/map__/${FTAG[red]}map__${FTAG[res]}${FTAG[brcyan]}} ${FTAG[brgreen]}$__ftag[$k]${FTAG[res]}"
        print
      done
      +Ftag::msg "{red}${(l:COLUMNS::=:):-}{res}"

      +Ftag::msg "{bgreen}${(l:COLUMNS/2:: :):-${FTAG[und]}OTHER CONFIG VARIABLES}{res}"
      +Ftag::msg "{red}${(l:COLUMNS::=:):-}{res}"
      adj=$(( $adj - ${#FTAG[red]} * 2 - ${#FTAG[res]}))
      for k in "${(@ok)^^__ftag[(I)^(map|key|action)__*]}"; do
        Ftag::map-short "$__ftag[$k]"
        [[ "$k" = colors ]] && {
          local -a col=( ${${(s: :)__ftag[$k]}/(#m)*/${FTAG[$MATCH]}${MATCH}${FTAG[res]}} )
          print -rn -- "${FTAG[red]}${(r:long+adj:: :)k}${FTAG[res]} $col"
        } || print -rn -- "${FTAG[red]}${(r:long+adj:: :)k}${FTAG[res]} $SHORT"
        print
      done
    } | ${${${(M)${${${dump##-(d|-dump(=|))}[-1]}//=/}:#(p|pager)}:+${(z)__ftag[pager]}}:-cat}

    [[ -z ${(M)${${${dump##-(d|-dump(=|))}[-1]}//=/}:#(p|pager)} ]] && {
      +Ftag::msg "{warn}use {yell}p{res} or {yell}pager{res} (no hyphens)"
    }
    exit 0
  }

  Ftag::opts "g genconfig" && {
    local ans
    [[ ! -d $keyfile:h ]] && { zf_mkdir -p $~keyfile:h || +Ftag::msg "{err}could not create ftag configuration directory"; exit 1; }
    [[ -f $keyfile ]] && {
      local symb="${${${(M)${langinfo[CODESET]:-$LANG}:#(#i)*UTF-8*}:â}:->>}"
      vared -cp "${FTAG[red]}Configuration already exists.${FTAG[res]} Generate another? [Y/n] $symb " ans
      [[ $ans != (#i)y(es|) ]] && { +Ftag::msg "{bryell}Configuration not generated{res}"; exit 0; }
    }

    builtin print -r "\
[keybindings]
?   = ACTION_HELP
A   = ACTION_ADD
D   = ACTION_REMOVE
E   = ACTION_EDIT
F   = ACTION_FILEMANAGER
G   = ACTION_GLOBAL
I   = ACTION_GIT
J   = ACTION_AUTOJUMP
L   = ACTION_LOCAL
O   = ACTION_OPEN
P   = ACTION_PREVIEW
Q   = ACTION_QUIT
R   = ACTION_RELOAD
S   = ACTION_SET
U   = ACTION_USAGE
V   = ACTION_VIEW
Z   = ACTION_ZOXIDE
C-b = ACTION_DOTBARE
C-d = ACTION_DUA
C-e = ACTION_GPG_EDIT
C-f = ACTION_FORGIT
C-g = ACTION_GPG
C-o = ACTION_FINDER
C-p = ACTION_PATH
C-r = ACTION_RIPGREP
C-s = ACTION_DIRSTACK
C-t = ACTION_TWF_EDIT
C-v = ACTION_EXTERNALVIEW
C-w = ACTION_GLOW
C-y = ACTION_COPY
M-c = ACTION_COPY_FILE
M-d = ACTION_DELETE
M-f = ACTION_FFSEND
M-i = ACTION_TOKEI
M-p = ACTION_DRAGON_SOURCE
M-s = ACTION_DUST
M-t = ACTION_VITAG
M-w = ACTION_OPEN_WITH

[dir_map]
ZDOTDIR         = $HOME/.config/zsh
XDG_CONFIG_HOME = $HOME/.config
XDG_CACHE_HOME  = $HOME/.cache
XDG_DATA_HOME   = $HOME/.local/share
XDG_BIN_HOME    = $HOME/bin
GHQ             = $HOME/ghq
GITHUB          = $HOME/github
PR_GITHUB       = $HOME/projects/github
DOWNLOADS       = $HOME/Downloads
DOCUMENTS       = $HOME/Documents
DESKTOP         = $HOME/Desktop
PICTURES        = $HOME/Pictures
LIBRARY         = $HOME/Library
APPLICATIONS    = $HOME/Applications
MUSIC           = $HOME/Music
MOVIES          = $HOME/Movies
WIKI_DIR        = $HOME/vimwiki
LOCAL_USR       = /usr/local
HOME            = $HOME

[env_vars]
FTAG_PAGER       = bat --paging=always -f
FTAG_COPY        = pbcopy
FTAG_MODIFIER    = ctrl
FTAG_ALT         = alt
FTAG_FILEMANAGER = lf
FTAG_FILE_PREV   = bat --style=numbers --color=always
FTAG_DIR_PREV    = exa -TL 3
FTAG_COLORS      =

[fzf]
fzf_command  = fzf
fzf_flags    =
fzf_bindings = alt-shift-down:preview-down,alt-shift-up:preview-up

[colors]
color_1 = bmagen
color_2 = blue
color_3 = green" >! "${~keyfile}"

    +Ftag::msg "{brgreen}Configuration generated:{res} {yell}${~keyfile}{res}"
    exit 0
  }
}

# Actions used for fzf
typeset -a __FTAG_ACTIONS
__FTAG_ACTIONS=( ${(@)${(k)FTAG_KEYBINDINGS//(#m)*/\-\-bind=$MATCH:${FTAG_KEYBINDINGS[${(z)MATCH}]}}} )

# ]]] == END: Config

# SECTION: == Create Filter == [[[
# File path content marks how to execute next command in the main loop
local current_filter
current_filter=${XDG_RUNTIME_DIR:-${XDG_CACHE_DIR:-${TMP-/tmp}}}/tag-filter
if { ! command touch $current_filter } {
  +Ftag::msg "{err}{brgreen}${prog}{res}: Can't create a marker file needed for internal state management.{res}"
}
# ]]] == END: Create Filter

# SECTION: == Actions == [[[
# Keys to show within the TUI
if [[ "${_FZFTAG_SHOW}" = "keys" ]]; then
  Ftag::default_header -s "ftag keybindings" -c 5
  local header
  local -a keys
  # Not sure how to put this in array as one element other than this, it reads as 3
  header=$(+Ftag::msg "{brred}KEY{tb}{tb}{brmagen}ACTION{tb}{tb}{tb}{tb}{byell}FZFTAG_ACTION{res}")
  line=$(+Ftag::msg "{brred}==={tb}{tb}{brmagen}======{tb}{tb}{tb}{tb}{bryell}============={res}")
  keys=( $header $line )
  keys+=( ${(@)${(f)"$(Ftag::show_keys -h)"}/$'\t'/} )
  print -rl -- $keys
  exit 0
fi

if [[ -n "$FZFTAG_ACTION" ]]; then
  # trap 'Ftag::tag ${(z)${(@f)"$(<$current_filter)"}}' EXIT
  clear
  # Get the filename e.g., %HOME/test
  local nl=$'\n' f
  typeset -ga pathf
  pathf=( ${(@)${${(f)"$(<$@)"}/(#m)*/${${(ws: :)MATCH}[1]}}} )
  # Call once for options that don't allow multiple
  Ftag::map-back "${pathf}"
  case "$FZFTAG_ACTION" in
    (test)
      # Testing for development
      local fname fdir tag file
      Ftag::parse_format "test"
      vared -cp "TEST: ${nl}$(Ftag::vared::formatter ${pathf[@]})${nl}${nl}ï Tags ï¡ " tag
      # for file in "${(f)reply[@]}"; do
      # done
      ;;
    (set)
      local fname fdir tag file
      Ftag::parse_format "set tags"
      vared -cp "${FTAG[byell]}[ï]${FTAG[res]} ${FTAG[und]}Set tags for${FTAG[res]}:${nl}$(Ftag::vared::formatter ${pathf[@]})${nl}${nl}ï¡ " tag
      for file in "${pathf[@]}"; do
        Ftag::map-back "$file"
        # Wutag only works if variables are set first
        fname="${reply:t}" fdir="${reply:h}"
        # Wutag is called in addition unless -ww
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -s "$fdir" "$fname" "$tag"
        } elif (( FZFTAG_WTAG == 1 )) {
          command tag --set "${tag}" "$file"
          Ftag::wutag -s "$fdir" "$fname" "$tag"
        } else {
          command tag --set "${tag}" "$reply"
        }
      done
      ;;
    (add)
      local fname fdir tag file
      Ftag::parse_format "add tags"
      vared -cp "${FTAG[bgreen]}[+ï«]${FTAG[res]} ${FTAG[und]}Add tags for${FTAG[res]}:${nl}$(Ftag::vared::formatter ${pathf[@]})${nl}${nl}ï¡ " tag
      for file in "${pathf[@]}"; do
        Ftag::map-back "$file"
        fname="${reply:t}" fdir="${reply:h}"
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -a "$fdir" "$fname" "$tag"
        } elif (( FZFTAG_WTAG == 1 )) {
          command tag --add "${tag}" "$reply"
          Ftag::wutag -a "$fdir" "$fname" "$tag"
        } else {
          command tag --add "${tag}" "$reply"
        }
      done
      ;;
    (remove)
      local fname fdir tag file
      Ftag::parse_format "remove tags"
      vared -cp "${FTAG[bred]}[ï]${FTAG[res]} ${FTAG[und]}Remove tags for${FTAG[res]}:${nl}$(Ftag::vared::formatter ${pathf[@]})${nl}${nl}ï¡ " tag
      for file in "${pathf[@]}"; do
        Ftag::map-back "$file"
        fname="${reply:t}" fdir="${reply:h}"
        if (( FZFTAG_WTAG > 1 )) {
          Ftag::wutag -r "$fdir" "$fname"
        } elif (( FZFTAG_WTAG == 1 )) {
          command tag --remove "${tag}" "$reply"
          Ftag::wutag -r "$fdir" "$fname"
        } else {
          command tag --remove "${tag}" "$reply"
        }
      done
      ;;
    (usage)
      tag --usage | ${${(z)${(M)${__ftag[pager]}:#bat*}:+${__ftag[pager]} -l bash}:-less}
      ;;
    (vitag)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with vitag"; return 1
      } || Ftag::dep "vitag" && vitag "${reply:A:h}"
      ;;
    (ffsend)
      Ftag::dep "ffsend" && () {
        builtin emulate -LR zsh
        setopt extendedglob noshortloops warncreateglobal
        local -a send
        local f; for f ($pathf) { Ftag::map-back "$f" && send+=( "$reply" ) }
        # TODO: add option for loop to do multiple files instead of archiving into single
        ffsend upload $send
      }
      ;;
    (tokei)
      Ftag::dep "tokei" && () {
        builtin emulate -LR zsh
        setopt extendedglob noshortloops warncreateglobal
        local -a tok
        local f; for f ($pathf) { Ftag::map-back "$f" && tok+=( "$reply" ) }
        tokei $tok
        read -qs
      }
      ;;
    (ripgrep)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with ripgrep"; return 1
      } || {
      local yesno keyw
      Ftag::parse_format "ripgrep search"
      vared -cp "Local search [Y/n]: " yesno
      vared -cp "ï¢ Ripgrep keyword: " keyw
      [[ "$yesno" == (#i)n(o|) ]] && {
        () {
            setopt localoptions noautopushd
            builtin cd -q "${reply:h}"
            Ftag::RG "$keyw"
          }
        } || Ftag::RG "$keyw"
      }
      ;;
    (edit)
      ${EDITOR:-vim} "$reply"
      ;;
    (file-manager)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with file-manager"; return 1
      } || $FTAG_FILEMANAGER "${reply:h}"
      ;;
    (git)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with git"; return 1
      } || {
        Ftag::is_git "${reply:h}" >/dev/null && Ftag::gitui "${reply:h}"
      }
      ;;
    (forgit)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with forgit"; return 1
      } || Ftag::forgit "${reply:h}"
      ;;
    (dotbare)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with dotbare"; return 1
      } || Ftag::dotbare "${reply:h}"
      ;;
    (gpg-edit)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with gpg-edit"; return 1
      } || Ftag::gpg -e "$reply"
      ;;
    (gpg)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with gpg"; return 1
      } || Ftag::gpg "$reply"
      ;;
    (dua)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with dua"; return 1
      } || Ftag::dua "${reply:h}"
      ;;
    (dust)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with dust"; return 1
      } || Ftag::dust "${reply:h}"
      ;;
    (twf-edit)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with twf-edit"; return 1
      } || { Ftag::dep "twf" && Ftag::twf -e "${reply:A:h}" }
      ;;
    (glow)
      (( $#pathf > 1 )) && {
        OS::notify "Only one selection is permitted with glow"; return 1
      } || Ftag::glow "${reply:A:h}"
      ;;
    (bat-view)
      () {
        builtin emulate -LR zsh -o extendedglob -o noshortloops -o warncreateglobal
        local -a batv
        local f; for f ($pathf) { Ftag::map-back "$f" && batv+=( "$reply" ) }
        ${${(z)${(M)${__ftag[pager]}:#bat*}:+bat --paging=always -f --style=header,snip}:-less} "${batv[@]}"
      }
      ;;
    (open-with)
      Ftag::open::with "${reply:A}"
      ;;
    (open-finder)
      () {
        builtin emulate -LR zsh -o noshortloops -o warncreateglobal
        local f; for f ($pathf) { Ftag::map-back "$f" && open "${reply:A:h}" } && exit
      }
      ;;
    (open)
      # External programs
      () {
        builtin emulate -LR zsh -o noshortloops -o warncreateglobal
        local f; for f ($pathf) {
          Ftag::map-back "$f"
          case "$(file --mime-type -b ${reply:A})" in
            (image/*) (
              Ftag::dep "feh" && ${commands[setsid]:-nohup} feh -. -x -B black -g 900x600-15+60 "${reply:A}"
              ) || (
              Ftag::dep "sxiv" && ${commands[setsid]:-nohup} sxiv -ai "${reply:A}"
              ) ;;
            (video/*)
              ${commands[setsid]:-nohup} mpv --ontop --no-border --force-window \
                    --autofit=500x280 --geometry=-15-53 "${reply:A}" ;;
            (audio/*) mpv "${reply:A}" ;;
            (application/pdf|application/vnd*|application/epub*) ${commands[setsid]:-nohup} zathura "${reply:A}" ;;
            (image/x-xcf) ${commands[setsid]:-nohup} gimp "${reply:A}" ;;
            (*) ${EDITOR:-vim} "${reply:A}" ;;
          esac
        } && exit
      }
    ;;
    (external-view)
      # TUI programs - no dependency checks
      (( $#pathf > 1 )) && { OS::notify "Only one selection is permitted with preview"; return 1 }
      {
        case "${reply:e}" in
          (text/html) w3m "${reply:A}" | ${(z)__ftag[pager]} ;;
          (zip) atool --list -- "${reply:A}" | ${(z)__ftag[pager]} ;;
          (tgz|tar.gz) tar tzf "${reply:A}" | ${(z)__ftag[pager]} ;;
          (tar.bz2|tbz2) tar tjf "${reply:A}" | ${(z)__ftag[pager]} ;;
          (tar.txz|txz) xz --list "${reply:A}" | ${(z)__ftag[pager]} ;;
          (tar) tar tf "${reply:A}" | ${(z)__ftag[pager]} ;;
          (jar|war|ear|oxt) unzip -l "${reply:A}" | ${(z)__ftag[pager]} ;;
          (rar) unrar l "${reply:A}" | ${(z)__ftag[pager]} ;;
          (7z) 7z l "${reply:A}" | ${(z)__ftag[pager]} ;;
          ([1-8]) man "${reply:A}" | col -b | ${(z)__ftag[pager]} ;;
          (o) nm "${reply:A}" | ${(z)__ftag[pager]} ;;
          (torrent) transmission-show "${reply:A}" | "${(z)__ftag[pager]}" ;;
          (iso) iso-info --no-header -l "${reply:A}" | ${(z)__ftag[pager]} ;;
          (odt|ods|odp|sxw) odt2txt "${reply:A}" | ${(z)__ftag[pager]} ;;
          (doc) catdoc "${reply:A}" | ${(z)__ftag[pager]} ;;
          (docx) docx2txt "${reply:A}" | ${(z)__ftag[pager]} ;;
          # (csv) bat "${reply:A}" | sed s/,/\\n/g ;;
          # (csv) bat --paging=always -f -l csv "${reply:A}" ;;
          (csv) ${(z)${${(M)__ftag[pager]:#bat*}:+${__ftag[pager]} -l csv}} "${reply:A}" ;;
          (json) jq --color-output . "${reply:A}" | ${(z)__ftag[pager]} ;;
          (asc) cat "${reply:A}" | ${(z)__ftag[pager]} ;;
          (sha1|sha256|sha512|md5) rhash -c "${reply:A}" | ${(z)__ftag[pager]} ;;
          (ipynb) jupview -t KimbieDark "${reply:A}" | ${(z)__ftag[pager]} ;;
          (pdf) pdftotext -l 10 -nopgbrk -q "${reply:A}" - | ${(z)__ftag[pager]} ;;
          (jpg|jpeg|png) viu "${reply:A}" | ${(z)__ftag[pager]} ;;
          # (*) mediainfo "${reply:A}" ;;
        esac
      } always {
          Ftag::dep "mediainfo" && mediainfo "${reply:A}" | ${(z)__ftag[pager]}
      }
      ;;
    (delete)
      () {
        builtin emulate -LR zsh
        builtin setopt noshortloops extendedglob ${${${+reply}:#0}:+warncreateglobal}
        local yesno; local -a array; integer ret=1
        local f; for f ($pathf) { Ftag::map-back "$f" && array+=( "$reply" ) }
        (( $#array > 1)) && {
          vared -cp "ï Delete files ${array[@]:t3}? [Y/n] " yesno
        } || vared -cp "ï Delete file ${array:t3}? [Y/n] " yesno
        [[ "$yesno" == (#i)y(es|) ]] && {
          for f ($array) {
            case 1 in
              (${+commands[dump]}) dump "${f}" && OS::notify "dump: ${f:t} deleted"; ret=$? ;;
              (${+commands[trash-put]}) trash-put "${f}" && OS::notify "put: ${f:t} deleted"; ret=$? ;;
              (${+commands[rip]}) rip "${f}" && OS::notify "rip: ${f:t} deleted"; ret=$? ;;
              (${+commands[gomi]}) gomi "${f}" && OS::notify "gomi: ${f:t} deleted"; ret=$? ;;
              (${+commands[osascript]})
                    osascript -e 'tell application "Finder" to delete every item of {''(POSIX file "'${^f:A}'")''}' \
                      >/dev/null
                      ret=$? ;;
              (*) zmodload -F zsh/files b:zf_rm && zf_rm "$f" && OS::notify "${f:t} deleted"; ret=$? ;;
            esac
          }
          return $ret
        }
      }
      ;;
    (copy)
      () {
        builtin emulate -LR zsh
        builtin setopt noshortloops extendedglob ${${${+reply}:#0}:+warncreateglobal}
        local -a array
        local f; for f ($pathf) { Ftag::map-back "$f" && array+=( "$reply" ) }
        ${(z)FTAG_COPY} <<< $array && return 0
      }
      ;;
    (dragon-source)
      () {
        builtin emulate -LR zsh
        builtin setopt noshortloops extendedglob ${${${+reply}:#0}:+warncreateglobal}
        local -a array; integer ret=1
        local f; for f ($pathf) { Ftag::map-back "$f" && array+=( "$reply" ) }
        Ftag::dep "dragon" && {
          dragon -x -p "${array[@]}" && ret=0
          exit $ret
        }
        return $ret
      }
      ;;
    (copy-file)
      Ftag::copy::file "$reply"
      ;;
  esac
  clear
  print -Pr -- "${FTAG[red]}${(l:COLUMNS::=:):-}${FTAG[res]}"
  print "End of 'ftag "$FZFTAG_ACTION"' output. Press any key to continue"
  print -Pr -- "${FTAG[red]}${(l:COLUMNS::=:):-}${FTAG[res]}"
  read -qs
  exit $?
fi
# ]]] == END: Actions

# SECTION: == State Change == [[[
local -a FZFTAG_CMD
local dir_switch
if [[ -n "$FZFTAG_STATE_CHANGE" ]]; then
  case "$FZFTAG_STATE_CHANGE" in
    local)
      FZFTAG_CMD=( "-Al" )
      ;;
    global)
      FZFTAG_CMD=( "-Af" "*" )
      ;;
    dirstack)
      dir_switch=$(Ftag::dirstack)
      [[ -d ${~dir_switch} ]] || { OS::notify "Not a directory"; return 1 }
      FZFTAG_CMD=( "-Af" "*" ${~dir_switch} )
      ;;
    path)
      dir_switch=$(Ftag::path::find)
      [[ -d ${~dir_switch} ]] || { OS::notify "Not a directory"; return 1 }
      FZFTAG_CMD=( "-Af" "*" ${~dir_switch} )
      ;;
    zoxide)
      dir_switch=$(Ftag::zoxide)
      [[ -d ${~dir_switch} ]] || { OS::notify "Not a directory"; return 1 }
      FZFTAG_CMD=( "-Af" "*" ${~dir_switch} )
      ;;
    autojump)
      dir_switch=$(Ftag::autojump)
      [[ -d ${~dir_switch} ]] || { OS::notify "Not a directory"; return 1 }
      FZFTAG_CMD=( "-Af" "*" ${~dir_switch} )
      ;;
  esac

  print -Rn "${FZFTAG_CMD[@]}" > $current_filter
  exit $?
fi
# ]]] == END: State Change

# SECTION: == Reload == [[[
# FIX: unused
local filter output
if [[ -n "$_FZFTAG_RELOAD" ]] {
  Ftag::tag "${(z)${(@f)"$(<$current_filter)"}}"
}
# ]]] == END: Reload

# SECTION: == Remove Filter == [[[
# No state change, no action, and no reload, remove filter
[[ $+FZFTAG_STATE_CHANGE -ne 1 && $+FZFTAG_ACTION -ne 1 && "${_FZFTAG_INTERNAL}" != "reload"
]] &&
  rm -f "$current_filter"
# ]]] == END: Remove Filter

# SECTION: == Preview == [[[
(( ${+FZFTAG_PREV} )) && {
  local -a pathf
  pathf=( ${(@)${${(f)"$(<$@)"}/(#m)*/${${(ws: :)MATCH}[1]}}} )
  Ftag::map-back "$pathf"
  [[ -f "$reply" ]] && ${(z)__ftag[file_prev]} "$reply"
  [[ -d "$reply" ]] && ${(z)__ftag[dir_prev]} "$reply" | ${commands[bat]:-less}
  exit $?
}
# ]]] == END: Prievew

# SECTION: == Main Loop == [[[
# Used for fzf preview
# Variables have to be exported to be picked up on the next iteration of the loop
typeset -giH {FZFTAG_WTAG,FZFTAG_BOXES,FZFTAG_LOLCAT,FZFTAG_TOILET,VERBOSE,NO_COLOR,WRAPPER}=0
typeset -gH  FZFTAG_STATE_CHANGE FZFTAG_FONT
while (( $? != 130 )) {
  VERBOSE=$#verbose
  Ftag::opts "n nocolor" && NO_COLOR=1

  if Ftag::opts "w wutag"; then
    if Ftag::dep "wutag"; then
      if (( $#wtag > 1 )) {
        export FZFTAG_WTAG=2
      } else {
        export FZFTAG_WTAG=1
      }
    else
      +Ftag::msg "{warn}{green}wutag{res} is not in PATH" \
        "{nl}Install {green}wutag{res} or don't use {yell}-w{res},{yell}--wutag{res}"
    fi
  fi

  (( ${+cfont} ))       && export FZFTAG_FONT=${${cfont##-(f|-font(=|))}[-1]}
  Ftag::opts "b boxes"  && export FZFTAG_BOXES=1
  Ftag::opts "c lolcat" && export FZFTAG_LOLCAT=1
  Ftag::opts "t toilet" && export FZFTAG_TOILET=1

  local -a tag_arguments
  # If writeable, that means theres a state change
  if [[ -w "$current_filter" ]]; then
    tag_arguments=( ${(@f)"$(<$current_filter)"} )
    LANG=C command sleep 0.002
  else
  # First time ran
    if Ftag::opts "l local"; then
      tag_arguments=( "-Al" )
    elif Ftag::opts "p path"; then
      tag_arguments=( "-Af" "*" "$FZFTAG_PATH" )
    elif Ftag::opts "z zoxide"; then
      Ftag::dep -e "zoxide"
      dir_switch=$(Ftag::zoxide)
      tag_arguments=( "-Af" "*" "$dir_switch" )
    elif Ftag::opts "j jump"; then
      Ftag::dep -e "autojump"
      dir_switch=$(Ftag::autojump)
      tag_arguments=( "-Af" "*" "$dir_switch" )
    else
      # Don't quote *
      tag_arguments=( "-Af" "${@:-*}" )
    fi
    print -Rn "${tag_arguments[@]}" >! $current_filter
  fi

  # Set prompt
  local -a FZFTAG_OPTS
  if Ftag::opts "l local" || [[ "$FZFTAG_STATE_CHANGE" = "local" ]]; then
    FZFTAG_OPTS=( "--prompt 'ï¬ Local Tag> '" )
  elif Ftag::opts "p path" || [[ "$FZFTAG_STATE_CHANGE" = "path" ]]; then
    FZFTAG_OPTS=( "--prompt 'ï¬ Path> '" )
  elif Ftag::opts "z zoxide" || [[ "$FZFTAG_STATE_CHANGE" = "zoxide" ]]; then
    FZFTAG_OPTS=( "--prompt 'ï Zoxide Tag> '" )
  elif Ftag::opts "j jump" || [[ "$FZFTAG_STATE_CHANGE" = "autojump" ]]; then
    FZFTAG_OPTS=( "--prompt 'ï Jump Tag> '" )
  else
    # FZFTAG_OPTS=( "--prompt 'Tag> '" "--delimiter /" "--with-nth 4.." )
    FZFTAG_OPTS=( "--prompt 'Tag> '" )
  fi

  [[ "${_FZFTAG_INTERNAL}" == "reload" ]] && {
    Ftag::tag "${(z)${(@f)"$(<$current_filter)"}}"
    exit $?
  }

  # local tfd
  # sysopen -r -o cloexec -u tfd <(() {
  #   eval 'Ftag::tag "${(z)tag_arguments}"';
  # } && terminal-notifier -title "x" -message "x")

  Ftag::opts "N nofzf" && {
    Ftag::tag "${(z)tag_arguments}"
    return
  }

  Ftag::opts "W wrapper" && {
    export WRAPPER=1
    wrapper=${${wrapper##-(w|-wrapper(=|))}[-1]/=/}
    # Not sure if this speeds up at all
    Ftag::parallel 'Ftag::tag "${wrapper}"'

    # zmodload -Fa zsh/zpty b:zpty && {
    #   zpty "ftag" 'Ftag::tag "${wrapper}"'
    #   zpty -r "ftag"
    #   zpty -d "ftag"
    # } || Ftag::tag "${wrapper}"
    return ret
  }

  Ftag::tag "${(z)tag_arguments}" \
    | $__ftag[fzf_command] \
      ${${(z)${(j. .)FZFTAG_OPTS}}//\'} \
      --bind=$__ftag[extra_binds] \
      --ansi \
      --query "$FZFTAG_QUERY" \
      --multi \
      --cycle \
      --info=inline \
      --pointer 'â¤' \
      --no-height \
      --preview-window=':hidden,right:60%' \
      --preview "env FZFTAG_PREV=1 $0 {+f}" \
      "${__FTAG_ACTIONS[@]}" \
      ${(z)__ftag[fzf_flags]}
}
# ]]] == END: Main Loop

# zle && zle reset-prompt || clear

# vim: ft=zsh:et:sw=0:ts=2:sts=2:fdm=marker:fmr=[[[,]]]:
